<!DOCTYPE html>
<!-- 
Family Checklists App
Version: V0.5.6
Last Updated: October 2, 2025 at 5:55 PM
-->
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Family Checklists</title>
<style>
:root{--bg:#0f172a;--card:#111827;--muted:#94a3b8;--text:#e5e7eb;--accent:#60a5fa;--accent-2:#34d399;--danger:#f87171;--outline:rgba(148,163,184,.25);--success-fg:#052e1b}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;transition:background .3s ease}
header{padding:12px 16px;background:var(--card);backdrop-filter:blur(6px);position:sticky;top:0;z-index:10;border-bottom:1px solid rgba(148,163,184,.15);transition:background .3s ease}
.header-top{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:12px}
.left{justify-self:start}.center{text-align:center;justify-self:center}.right{justify-self:end;display:flex;gap:8px;flex-wrap:wrap}
.title{font-size:16px;font-weight:700}.subtitle{font-size:12px;color:var(--muted)}
.clock{font-size:36px;line-height:1;font-weight:800}.bedtime{font-size:12px;color:var(--muted);margin-top:4px}
.day-progress{height:10px;background:rgba(148,163,184,.25);border-radius:999px;overflow:hidden;margin-top:10px}
.day-progress .bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent-2));transition:width .3s ease}
.container{padding:16px;max-width:980px;margin:0 auto}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:14px}
.card{background:var(--card);border:1px solid rgba(148,163,184,.15);border-radius:18px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);transition:background .3s ease,border-color .2s ease}
.person{display:flex;align-items:center;justify-content:space-between;gap:8px}.person h2{margin:0;font-size:18px}
.pill{font-size:12px;color:#0b1224;background:#60a5fa;border-radius:999px;padding:4px 10px;font-weight:700}
.pill.danger{background:#f87171;color:#210404}.pill.success{background:#34d399;color:var(--success-fg)}
.btn{appearance:none;border:1px solid rgba(148,163,184,.2);background:#0b1224;color:var(--text);padding:10px 12px;border-radius:12px;font-weight:600;cursor:pointer;transition:background .15s,border-color .15s}
.btn:hover{background:rgba(148,163,184,.1);border-color:rgba(148,163,184,.3)}
.btn.small{padding:6px 9px;font-size:12px}.btn.ghost{background:transparent;border-color:rgba(148,163,184,.15)}
.btn.saved{background:#34d399;border-color:#34d399;color:#fff}
.muted{color:var(--muted)}.progress{height:10px;background:rgba(148,163,184,.25);border-radius:999px;overflow:hidden}
.bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent-2));transition:width .3s ease}
.spacer{height:8px}
.card.clickable{cursor:pointer;transition:all .2s ease}
.card.clickable:hover{border-color:rgba(148,163,184,.35);box-shadow:0 12px 36px rgba(0,0,0,.35);transform:translateY(-1px)}
.detail{max-width:720px;margin:0 auto}
.task{display:flex;gap:12px;align-items:flex-start;padding:12px;border-radius:12px;border:1px solid rgba(148,163,184,.15);margin-bottom:10px;background:rgba(2,6,23,.6);transition:all .2s ease}
.task.overdue{border-color:#f87171;background:rgba(248,113,113,.08)}
.task.skipped{opacity:0.6}
.task.skipped .label{text-decoration:line-through}
.task input[type=checkbox]{width:22px;height:22px;cursor:pointer}
.task .label{font-size:15px;line-height:1.3}.when{font-size:11px;color:var(--muted)}
.row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
footer{padding:12px 16px;color:var(--muted);font-size:12px;text-align:center}
.hidden{display:none}
.badge{border:1px solid rgba(148,163,184,.25);padding:2px 8px;border-radius:999px;font-size:11px;color:var(--muted)}
.editor{max-width:980px;margin:0 auto}
.form-card{border:1px solid var(--outline);border-radius:16px;padding:16px;margin-bottom:14px;background:var(--card);transition:background .3s ease}
.form-row{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:10px}
.field{display:flex;flex-direction:column;gap:6px}
label{font-size:12px;color:var(--muted)}
input[type=text],input[type=time],input[type=number],select,input[type=password]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--outline);background:rgba(17,24,39,.6);color:var(--text)}
.member-card{border:1px dashed var(--outline);border-radius:12px;padding:12px;margin-bottom:12px}
.member-card{border:2px solid var(--outline);border-radius:16px;padding:20px;margin-bottom:20px;background:rgba(0,0,0,.2)}
.member-card:nth-child(odd){background:rgba(96,165,250,.05)}
.member-card:nth-child(even){background:rgba(52,211,153,.05)}
.settings-section{background:rgba(0,0,0,.15);border-radius:12px;padding:16px;margin-top:16px;border:1px solid rgba(148,163,184,.1)}
.task-row{display:grid;grid-template-columns:160px 1fr auto;gap:8px;margin-top:8px;align-items:center}
.goal-row{display:grid;grid-template-columns:1fr 120px 100px 80px auto;gap:8px;margin-top:8px;align-items:start}
.goal-section{background:rgba(251,191,36,.08);border:1px solid rgba(251,191,36,.25);border-radius:12px;padding:12px;margin-bottom:12px}
.goal-badge{background:rgba(251,191,36,.15);color:#fbbf24;border:1px solid rgba(251,191,36,.3);padding:4px 8px;border-radius:6px;font-size:11px;font-weight:600;display:inline-block}
.goal-progress-bar{height:8px;background:rgba(251,191,36,.2);border-radius:4px;overflow:hidden;margin:8px 0}
.goal-progress-bar .bar{height:100%;background:linear-gradient(90deg,#fbbf24,#f59e0b);transition:width .3s ease}
.task-selector{font-size:11px;color:var(--muted);margin-top:8px;padding:8px;background:rgba(0,0,0,.2);border-radius:8px}
.task-selector label{display:block;margin:4px 0;cursor:pointer}
.task-selector input[type=checkbox]{margin-right:6px}
.toggle-switch{position:relative;width:200px;height:35px;background:rgba(17,24,39,.6);border:1px solid var(--outline);border-radius:10px;cursor:pointer;display:flex;align-items:center;padding:3px;transition:all .3s ease}
.toggle-switch.active{background:rgba(34,197,94,.15);border-color:rgba(34,197,94,.5)}
.toggle-switch.inactive{background:rgba(239,68,68,.15);border-color:rgba(239,68,68,.5)}
.toggle-slider{position:absolute;width:calc(50% - 3px);height:29px;background:var(--text);border-radius:8px;transition:all .3s ease;display:flex;align-items:center;justify-content:center;font-weight:600;box-shadow:0 2px 4px rgba(0,0,0,.2);font-size:12px}
.toggle-switch.active .toggle-slider{left:calc(50% + 1.5px);background:#22c55e;color:white}
.toggle-switch.inactive .toggle-slider{left:3px;background:#ef4444;color:white}
.toggle-labels{width:100%;display:flex;position:relative;z-index:0;pointer-events:none}
.toggle-label{flex:1;text-align:center;font-size:12px;font-weight:600;color:transparent;user-select:none}
.color-themes{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}
.theme-option{cursor:pointer;border:2px solid transparent;border-radius:8px;padding:8px;transition:all .2s ease;text-align:center}
.theme-option:hover{transform:scale(1.05)}
.theme-option.selected{border-color:var(--accent);box-shadow:0 0 0 2px rgba(96,165,250,.3)}
.theme-preview{height:40px;border-radius:6px;margin-bottom:6px;display:flex}
.theme-preview .c1{flex:1;border-radius:6px 0 0 6px}
.theme-preview .c2{flex:1;border-radius:0 6px 6px 0}
.theme-label{font-size:11px;color:var(--muted)}
.screensaver{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:9999;display:flex;align-items:center;justify-content:center;cursor:pointer}
.screensaver-content{position:absolute;font-size:32px;color:#fff;text-align:center;padding:40px;max-width:80%;line-height:1.6;text-shadow:2px 2px 4px rgba(0,0,0,0.5);animation:floatAround 20s infinite ease-in-out}
@keyframes floatAround{0%{top:20%;left:10%;opacity:0}10%{opacity:1}45%{opacity:1}55%{opacity:0}60%{top:60%;left:70%;opacity:0}70%{opacity:1}95%{opacity:1}100%{top:20%;left:10%;opacity:0}}
.screensaver-hint{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);color:rgba(255,255,255,0.3);font-size:14px}
.modal-backdrop{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:1000}
.modal{background:#111827;border:1px solid var(--outline);border-radius:16px;padding:20px;max-width:400px;width:90%}
.modal-body{margin-bottom:16px;font-size:14px}
.sync-status{font-size:11px;padding:4px 8px;border-radius:6px;background:rgba(34,197,94,.15);color:#22c55e;border:1px solid rgba(34,197,94,.3)}
.sync-status.syncing{background:rgba(251,191,36,.15);color:#fbbf24;border-color:rgba(251,191,36,.3)}
.sync-status.error{background:rgba(239,68,68,.15);color:#ef4444;border-color:rgba(239,68,68,.3)}
.pet-container{position:relative;display:inline-block}
.mood-indicator{position:absolute;top:-5px;right:-5px;font-size:20px;line-height:1;animation:bounce 0.5s ease-in-out infinite;animation-iteration-count:1}
@keyframes bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-5px)}}
.pet-container{animation:petBounce 30s ease-in-out infinite}
@keyframes petBounce{0%,98%,100%{transform:translateY(0)}99%{transform:translateY(-8px)}}
@media (pointer:coarse){
.btn{padding:16px 20px;font-size:18px}
.btn.small{padding:12px 16px;font-size:16px}
.task input[type=checkbox]{width:32px;height:32px}
.task{padding:16px}
.task .label{font-size:17px}
.clock{font-size:48px}.bedtime{font-size:16px}
.title{font-size:18px}.subtitle{font-size:14px}
.person h2{font-size:20px}
.pill{font-size:14px;padding:6px 12px}
input[type=text],input[type=time],input[type=number],select,input[type=password]{padding:14px 16px;font-size:16px}
label{font-size:14px}
.form-row{grid-template-columns:1fr}
.task-row{grid-template-columns:1fr;gap:12px}
.task-row input, .task-row button{width:100%;margin-bottom:8px}
.goal-row{grid-template-columns:1fr;gap:12px}
.goal-row input, .goal-row select, .goal-row button{width:100%;margin-bottom:8px}
.color-themes{grid-template-columns:repeat(2,1fr)}
.muted{font-size:14px}
.card{padding:20px}
.mood-indicator{font-size:24px;top:-8px;right:-8px}
.member-card{padding:16px}
.settings-section{padding:12px}
.row{gap:12px}
h2{font-size:20px}
h3{font-size:16px}
.toggle-switch{width:100%;max-width:300px}
.field{margin-bottom:12px}
.form-card{padding:16px}
}
</style>
</head>
<body>
<header>
<div class="header-top">
<div class="left">
<div class="title" id="appTitle">Family Checklists</div>
<div class="subtitle" id="subtitle"></div>
</div>
<div class="center">
<div id="clock" class="clock">–:–</div>
<div id="bedtime" class="bedtime">--:-- until bedtime</div>
</div>
<div class="right">
<span id="syncStatus" class="sync-status hidden">Synced</span>
<button class="btn small ghost" id="todayBtn" title="Go to Home">Home</button>
<button class="btn small ghost" id="statsBtn" title="View Stats & Analytics">📊</button>
<button class="btn small" id="editBtn" title="Edit settings & members">⚙️</button>
</div>
</div>
<div id="dayProgress" class="day-progress" role="progressbar">
<div id="dayProgressBar" class="bar"></div>
</div>
</header>
<main class="container">
<section id="summary" class="grid"></section>
<section id="detail" class="hidden"></section>
<section id="dashboard" class="hidden"></section>
<section id="editor" class="hidden editor"></section>
</main>
<footer>Tap a name to open their checklist. Progress syncs across all devices in real-time.</footer>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
import { getDatabase, ref, set, get, onValue, update } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

const firebaseConfig = {
  apiKey: "AIzaSyB2FPF58eJEshn5F1x3LvQP6yiJXMfZ9AY",
  authDomain: "family-tracker-app-9e8b4.firebaseapp.com",
  databaseURL: "https://family-tracker-app-9e8b4-default-rtdb.firebaseio.com",
  projectId: "family-tracker-app-9e8b4",
  storageBucket: "family-tracker-app-9e8b4.firebasestorage.app",
  messagingSenderId: "851134413681",
  appId: "1:851134413681:web:2d189c6227e841998314d0"
};

const firebaseApp = initializeApp(firebaseConfig);
const database = getDatabase(firebaseApp);

(function() {
'use strict';

const APP_VERSION = 'V0.5.6';

const SCREENSAVER_CONTENT = {
  verses: [
    "Be strong and courageous. Do not be afraid; do not be discouraged. - Joshua 1:9",
    "Trust in the Lord with all your heart. - Proverbs 3:5",
    "I can do all things through Christ who strengthens me. - Philippians 4:13",
    "Love is patient, love is kind. - 1 Corinthians 13:4",
    "For God so loved the world that he gave his one and only Son. - John 3:16",
    "The Lord is my shepherd; I shall not want. - Psalm 23:1",
    "Do not worry about tomorrow, for tomorrow will worry about itself. - Matthew 6:34",
    "Cast all your anxiety on him because he cares for you. - 1 Peter 5:7",
    "In all things God works for the good of those who love him. - Romans 8:28",
    "Be still, and know that I am God. - Psalm 46:10"
  ],
  facts: [
    "Honey never spoils. Archaeologists have found 3,000 year old honey in Egyptian tombs that's still edible!",
    "A group of flamingos is called a 'flamboyance'.",
    "The shortest war in history lasted only 38 minutes between Britain and Zanzibar in 1896.",
    "Octopuses have three hearts and blue blood.",
    "Bananas are berries, but strawberries aren't!",
    "The Great Wall of China is not visible from space with the naked eye.",
    "A bolt of lightning contains enough energy to toast 100,000 slices of bread.",
    "The human brain uses 20% of the body's energy despite being only 2% of its weight.",
    "There are more possible iterations of a chess game than atoms in the observable universe.",
    "Butterflies can taste with their feet."
  ],
  words: [
    "Serendipity - Finding something good without looking for it",
    "Resilience - The ability to bounce back from difficulties",
    "Gratitude - Being thankful for what you have",
    "Perseverance - Continuing despite challenges",
    "Compassion - Deep awareness of others' suffering with desire to help",
    "Integrity - Doing the right thing even when no one is watching",
    "Courage - Strength in the face of fear",
    "Wisdom - The quality of having experience and good judgment",
    "Kindness - Being friendly, generous, and considerate",
    "Hope - A feeling of expectation and desire for a certain thing to happen"
  ]
};

const COLOR_THEMES = {
  blue: {name: 'Ocean Blue', primary: '#1e3a8a', secondary: '#60a5fa', bg: 'linear-gradient(180deg, #0c1e44, #0f172a)', card: 'rgba(30, 58, 138, 0.15)'},
  purple: {name: 'Purple Dream', primary: '#581c87', secondary: '#a855f7', bg: 'linear-gradient(180deg, #1e0a2e, #0f172a)', card: 'rgba(88, 28, 135, 0.15)'},
  orange: {name: 'Sunset', primary: '#9a3412', secondary: '#fb923c', bg: 'linear-gradient(180deg, #2c1810, #0f172a)', card: 'rgba(154, 52, 18, 0.15)'},
  green: {name: 'Forest', primary: '#14532d', secondary: '#22c55e', bg: 'linear-gradient(180deg, #0a2818, #0f172a)', card: 'rgba(20, 83, 45, 0.15)'},
  red: {name: 'Cherry', primary: '#7f1d1d', secondary: '#ef4444', bg: 'linear-gradient(180deg, #2d0a0a, #0f172a)', card: 'rgba(127, 29, 29, 0.15)'},
  cyan: {name: 'Ocean', primary: '#0e7490', secondary: '#06b6d4', bg: 'linear-gradient(180deg, #0a2530, #0f172a)', card: 'rgba(14, 116, 144, 0.15)'},
  pink: {name: 'Bubblegum', primary: '#831843', secondary: '#ec4899', bg: 'linear-gradient(180deg, #2d0a1e, #0f172a)', card: 'rgba(131, 24, 67, 0.15)'},
  amber: {name: 'Goldenrod', primary: '#78350f', secondary: '#f59e0b', bg: 'linear-gradient(180deg, #2a1808, #0f172a)', card: 'rgba(120, 53, 15, 0.15)'}
};

const DEFAULT_CONFIG = {
  appTitle: 'Family Checklists',
  resetHour: 21,
  colorTheme: 'blue',
  morningEnd: {h: 12, m: 0},
  afternoonEnd: {h: 17, m: 0},
  wakeParent: {h: 6, m: 0},
  wakeKids: {h: 6, m: 0},
  bedtimeKids: {h: 21, m: 0},
  bedtimeParents: {h: 21, m: 0},
  pinEnabled: false,
  pinHash: null,
  pinSalt: null,
  pinHint: '',
  recoveryPhrase: '',
  screensaverEnabled: true,
  screensaverTimeout: 300,
  screensaverGenre: 'all',
  people: []
};

// Firebase-backed storage
let syncInProgress = false;

async function loadConfig() {
  try {
    setSyncStatus('syncing');
    const snapshot = await get(ref(database, 'config'));
    if (snapshot.exists()) {
      const data = snapshot.val();
      // Ensure people array exists
      if (!data.people) data.people = [];
      setSyncStatus('synced');
      return data;
    }
    const defaultCfg = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
    await set(ref(database, 'config'), defaultCfg);
    setSyncStatus('synced');
    return defaultCfg;
  } catch (error) {
    console.error('Error loading config:', error);
    setSyncStatus('error');
    return JSON.parse(JSON.stringify(DEFAULT_CONFIG));
  }
}

async function saveConfig(cfg) {
  try {
    setSyncStatus('syncing');
    await set(ref(database, 'config'), cfg);
    applyColorTheme(cfg.colorTheme);
    setSyncStatus('synced');
    return cfg;
  } catch (error) {
    console.error('Error saving config:', error);
    setSyncStatus('error');
    return cfg;
  }
}

async function loadState() {
  try {
    const snapshot = await get(ref(database, 'state'));
    if (snapshot.exists()) {
      const state = snapshot.val();
      // Ensure overdueCompleted exists
      if (!state.overdueCompleted) state.overdueCompleted = {};
      return state;
    }
    const defaultState = {checked: {}, skipped: {}, overdueCompleted: {}, lastResetStamp: null};
    await set(ref(database, 'state'), defaultState);
    return defaultState;
  } catch (error) {
    console.error('Error loading state:', error);
    return {checked: {}, skipped: {}, overdueCompleted: {}, lastResetStamp: null};
  }
}

async function saveState(state) {
  if (syncInProgress) return;
  try {
    syncInProgress = true;
    setSyncStatus('syncing');
    await set(ref(database, 'state'), state);
    setSyncStatus('synced');
  } catch (error) {
    console.error('Error saving state:', error);
    setSyncStatus('error');
  } finally {
    syncInProgress = false;
  }
}

async function loadGoalState() {
  try {
    const snapshot = await get(ref(database, 'goals'));
    if (snapshot.exists()) {
      return snapshot.val();
    }
    const defaultGoals = {streaks: {}, totals: {}, lastCompletionDate: {}, achievements: {}};
    await set(ref(database, 'goals'), defaultGoals);
    return defaultGoals;
  } catch (error) {
    console.error('Error loading goals:', error);
    return {streaks: {}, totals: {}, lastCompletionDate: {}, achievements: {}};
  }
}

async function saveGoalState(goalState) {
  if (syncInProgress) return;
  try {
    syncInProgress = true;
    setSyncStatus('syncing');
    await set(ref(database, 'goals'), goalState);
    setSyncStatus('synced');
  } catch (error) {
    console.error('Error saving goal state:', error);
    setSyncStatus('error');
  } finally {
    syncInProgress = false;
  }
}

function setSyncStatus(status) {
  const el = document.getElementById('syncStatus');
  el.classList.remove('hidden', 'syncing', 'error');
  if (status === 'syncing') {
    el.classList.add('syncing');
    el.textContent = 'Syncing...';
  } else if (status === 'error') {
    el.classList.add('error');
    el.textContent = 'Sync Error';
  } else {
    el.textContent = 'Synced';
  }
  el.classList.remove('hidden');
  setTimeout(() => {
    if (status !== 'error') el.classList.add('hidden');
  }, 2000);
}

function applyColorTheme(themeName) {
  const theme = COLOR_THEMES[themeName] || COLOR_THEMES.blue;
  document.documentElement.style.setProperty('--accent', theme.secondary);
  document.documentElement.style.setProperty('--accent-2', theme.secondary);
  document.body.style.background = theme.bg;
  document.documentElement.style.setProperty('--card', theme.card);
  
  const header = document.querySelector('header');
  if (header) header.style.background = theme.card;
  
  document.querySelectorAll('.card, .form-card').forEach(card => {
    card.style.background = theme.card;
  });
}

function pad2(n) { return String(n).padStart(2, '0'); }
function uid(prefix) { return prefix + '_' + Math.random().toString(36).slice(2, 8) + '_' + Date.now(); }
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}

function hashPin(pin, salt) {
  let hash = 2166136261;
  const str = pin + '|' + salt;
  for (let i = 0; i < str.length; i++) {
    hash ^= str.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return ('00000000' + (hash >>> 0).toString(16)).slice(-8);
}

function to12(h) { return (h % 24) % 12 || 12; }
function ampm(h) { return (h % 24) < 12 ? 'AM' : 'PM'; }
function timeString12(tm) { return to12(tm.h) + ':' + pad2(tm.m) + ' ' + ampm(tm.h); }

function parseTimeFlexible(s) {
  if (!s) return null;
  s = String(s).trim();
  const m = s.match(/^(\d{1,2})(?::(\d{1,2}))?\s*(am|pm)?$/i);
  if (!m) return null;
  let h = parseInt(m[1], 10);
  let mm = m[2] !== undefined ? parseInt(m[2], 10) : 0;
  const ap = m[3] ? m[3].toLowerCase() : null;
  if (!ap) return null;
  if (ap) {
    if (h === 12) h = 0;
    if (ap === 'pm') h += 12;
  }
  if (h < 0 || h > 23 || mm < 0 || mm > 59) return null;
  return {h, m: mm};
}

function determineTaskPeriod(taskTime) {
  if (!taskTime) return 'evening';
  const taskMins = minutesOf(taskTime);
  const morningEndMins = minutesOf(app.CONFIG.morningEnd || {h: 12, m: 0});
  const afternoonEndMins = minutesOf(app.CONFIG.afternoonEnd || {h: 17, m: 0});
  if (taskMins < morningEndMins) return 'morning';
  if (taskMins < afternoonEndMins) return 'afternoon';
  return 'evening';
}

function nowMinutes() {
  const d = new Date();
  return d.getHours() * 60 + d.getMinutes();
}

function minutesOf(tm) { return tm.h * 60 + tm.m; }

function getTaskTime(t) {
  if (t.time && Number.isFinite(t.time.h) && Number.isFinite(t.time.m)) {
    return {h: t.time.h, m: t.time.m};
  }
  const m = String(t.label || '').match(/^\s*(\d{1,2}):(\d{2})\s*[\u2013\-]/);
  if (!m) return null;
  let h = parseInt(m[1], 10), mm = parseInt(m[2], 10);
  if (h >= 0 && h <= 23 && mm >= 0 && mm <= 59) return {h, m: mm};
  return null;
}

function stripLeadingTime(label) {
  return String(label).replace(/^\s*\d{1,2}:\d{2}\s*[\u2013\-]\s*/, '');
}

function stampFor(date) {
  const d = new Date(date);
  const pivot = new Date(d);
  pivot.setHours(app.CONFIG.resetHour, 0, 0, 0);
  return d < pivot ?
    `${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()-1}` :
    `${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()}`;
}

function getPetState(completionPct, person, nowMins) {
  // Check for incomplete tasks first (highest priority) - excluding skipped
  if (person && person.tasks) {
    const hasIncomplete = person.tasks.some(t => {
      if (isSkipped(person.id, t.id)) return false; // Exclude skipped tasks
      const tm = getTaskTime(t);
      return tm && nowMins >= minutesOf(tm) + 30 && !isChecked(person.id, t.id) && !isOverdueCompleted(person.id, t.id);
    });
    if (hasIncomplete) {
      return {emoji: '😄', state: 'needs attention', color: '#ef4444', indicator: '💢'};
    }
  }
  
  // Check if within 30 minutes of bedtime
  if (person && person.bedTime) {
    const bedMins = minutesOf(person.bedTime);
    const minsUntilBed = bedMins - nowMins;
    if (minsUntilBed >= 0 && minsUntilBed <= 30) {
      return {emoji: '😄', state: 'is getting tired', color: '#8b5cf6', indicator: '💤'};
    }
  }
  
  // Use completion percentage for other states (excluding skipped tasks from calculation)
  if (completionPct >= 71) {
    return {emoji: '😄', state: 'is feeling amazing', color: '#22c55e', indicator: '✨'};
  } else if (completionPct >= 41) {
    return {emoji: '🙂', state: 'is happy', color: '#f59e0b', indicator: '❤️'};
  } else {
    return {emoji: '😴', state: 'isn\'t feeling good', color: '#94a3b8', indicator: '😢'};
  }
}

function getDateStamp(date = new Date()) {
  return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
}

function shouldShowTaskToday(task) {
  const today = new Date();
  const dayOfWeek = today.getDay(); // 0 = Sunday, 6 = Saturday
  const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 86400000);
  
  const frequency = task.frequency || 'daily';
  
  switch(frequency) {
    case 'daily':
      return true;
    case 'everyother':
      return dayOfYear % 2 === 0;
    case 'weekdays':
      return dayOfWeek >= 1 && dayOfWeek <= 5;
    case 'weekends':
      return dayOfWeek === 0 || dayOfWeek === 6;
    default:
      return true;
  }
}

function groupByWhen(tasks) {
  return tasks.reduce((a, t) => {
    (a[t.when] || (a[t.when] = [])).push(t);
    return a;
  }, {});
}

function countWhen(p, when) {
  const tot = p.tasks.filter(t => t.when === when).length;
  const dn = p.tasks.filter(t => t.when === when && isChecked(p.id, t.id)).length;
  return dn + '/' + tot;
}

async function ensureDailyReset() {
  const todayStamp = stampFor(new Date());
  if (app.state.lastResetStamp !== todayStamp) {
    app.state.checked = {};
    app.state.skipped = {};
    app.state.overdueCompleted = {};
    app.state.lastResetStamp = todayStamp;
    await saveState(app.state);
  }
}

function key(personId, taskId) { return personId + '::' + taskId; }
function isChecked(personId, taskId) { 
  if (!app.state || !app.state.checked) {
    console.log(`isChecked(${personId}, ${taskId}): app.state or checked is missing`);
    return false;
  }
  const k = key(personId, taskId);
  const result = !!app.state.checked[k];
  console.log(`isChecked(${k}): ${result}`);
  return result;
}
function isOverdueCompleted(personId, taskId) {
  if (!app.state || !app.state.overdueCompleted) {
    console.log(`isOverdueCompleted(${personId}, ${taskId}): app.state or overdueCompleted is missing`);
    return false;
  }
  const k = key(personId, taskId);
  const result = !!app.state.overdueCompleted[k];
  console.log(`isOverdueCompleted(${k}): ${result}`);
  return result;
}
async function setChecked(personId, taskId, v, task, nowMins) {
  if (!app.state) app.state = {checked: {}, skipped: {}, overdueCompleted: {}, lastResetStamp: null};
  if (!app.state.checked) app.state.checked = {};
  if (!app.state.skipped) app.state.skipped = {};
  if (!app.state.overdueCompleted) app.state.overdueCompleted = {};
  
  const k = key(personId, taskId);
  
  if (v) {
    // Check if task is being checked late
    const tm = getTaskTime(task);
    const isLate = tm && nowMins >= minutesOf(tm) + 30;
    
    if (isLate) {
      // Mark as overdue completed
      app.state.overdueCompleted[k] = true;
      delete app.state.checked[k];
    } else {
      // Mark as completed on time
      app.state.checked[k] = true;
      delete app.state.overdueCompleted[k];
    }
    delete app.state.skipped[k];
  } else {
    // Unchecking - remove from both
    delete app.state.checked[k];
    delete app.state.overdueCompleted[k];
  }
  
  console.log('Saving state:', JSON.stringify(app.state, null, 2)); // Debug log
  await saveState(app.state);
}
function isSkipped(personId, taskId) { 
  if (!app.state || !app.state.skipped) return false;
  return !!app.state.skipped[key(personId, taskId)]; 
}
async function setSkipped(personId, taskId, v) {
  if (!app.state) app.state = {checked: {}, skipped: {}, overdueCompleted: {}, lastResetStamp: null};
  if (!app.state.checked) app.state.checked = {};
  if (!app.state.skipped) app.state.skipped = {};
  if (!app.state.overdueCompleted) app.state.overdueCompleted = {};
  
  if (v) {
    app.state.skipped[key(personId, taskId)] = true;
    delete app.state.checked[key(personId, taskId)];
    delete app.state.overdueCompleted[key(personId, taskId)];
  } else {
    delete app.state.skipped[key(personId, taskId)];
  }
  await saveState(app.state);
}

async function clearPerson(personId) {
  if (!app.state) app.state = {checked: {}, skipped: {}, overdueCompleted: {}, lastResetStamp: null};
  if (!app.state.checked) app.state.checked = {};
  if (!app.state.skipped) app.state.skipped = {};
  if (!app.state.overdueCompleted) app.state.overdueCompleted = {};
  
  Object.keys(app.state.checked).forEach(k => {
    if (k.startsWith(personId + '::')) delete app.state.checked[k];
  });
  Object.keys(app.state.skipped).forEach(k => {
    if (k.startsWith(personId + '::')) delete app.state.skipped[k];
  });
  Object.keys(app.state.overdueCompleted).forEach(k => {
    if (k.startsWith(personId + '::')) delete app.state.overdueCompleted[k];
  });
  await saveState(app.state);
}

function getGoalProgress(personId, goal) {
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return {current: 0, target: goal.target};
  
  // Ensure tasks array exists
  if (!person.tasks || !Array.isArray(person.tasks)) {
    person.tasks = [];
  }
  
  let tasksToCheck;
  if (goal.trackAll) {
    tasksToCheck = person.tasks;
  } else if (goal.trackPeriod) {
    tasksToCheck = person.tasks.filter(t => t.when === goal.trackPeriod);
  } else {
    tasksToCheck = person.tasks.filter(t => goal.taskIds && goal.taskIds.includes(t.id));
  }
  
  const completed = tasksToCheck.filter(t => isChecked(personId, t.id) || isOverdueCompleted(personId, t.id)).length;
  
  if (goal.type === 'streak') {
    const goalKey = personId + '_' + goal.id;
    const current = (app.goalState && app.goalState.streaks) ? (app.goalState.streaks[goalKey] || 0) : 0;
    return {current, target: goal.target};
  } else {
    const goalKey = personId + '_' + goal.id;
    const current = (app.goalState && app.goalState.totals) ? (app.goalState.totals[goalKey] || 0) : 0;
    return {current, target: goal.target};
  }
}

async function recalculateGoalProgress(personId, goal) {
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return;
  
  // Ensure tasks array exists
  if (!person.tasks || !Array.isArray(person.tasks)) {
    person.tasks = [];
  }
  
  let tasksToCheck;
  if (goal.trackAll) {
    tasksToCheck = person.tasks;
  } else if (goal.trackPeriod) {
    tasksToCheck = person.tasks.filter(t => t.when === goal.trackPeriod);
  } else {
    tasksToCheck = person.tasks.filter(t => goal.taskIds && goal.taskIds.includes(t.id));
  }
  
  const completed = tasksToCheck.filter(t => isChecked(personId, t.id) || isOverdueCompleted(personId, t.id)).length;
  const total = tasksToCheck.length;
  const pct = total > 0 ? (completed / total) * 100 : 0;
  
  const goalKey = personId + '_' + goal.id;
  const today = getDateStamp();
  
  if (pct < 100 && app.goalState.lastCompletionDate[goalKey] === today) {
    delete app.goalState.lastCompletionDate[goalKey];
    
    if (goal.type === 'total' && app.goalState.totals[goalKey] > 0) {
      app.goalState.totals[goalKey] = app.goalState.totals[goalKey] - 1;
    }
    if (goal.type === 'streak') {
      app.goalState.streaks[goalKey] = 0;
    }
    await saveGoalState(app.goalState);
  }
}

async function updateGoalProgress(personId, goal) {
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return;
  
  // Ensure tasks array exists
  if (!person.tasks || !Array.isArray(person.tasks)) {
    person.tasks = [];
  }
  
  let tasksToCheck;
  if (goal.trackAll) {
    tasksToCheck = person.tasks;
  } else if (goal.trackPeriod) {
    tasksToCheck = person.tasks.filter(t => t.when === goal.trackPeriod);
  } else {
    tasksToCheck = person.tasks.filter(t => goal.taskIds && goal.taskIds.includes(t.id));
  }
  
  const completed = tasksToCheck.filter(t => isChecked(personId, t.id) || isOverdueCompleted(personId, t.id)).length;
  const total = tasksToCheck.length;
  const pct = total > 0 ? (completed / total) * 100 : 0;
  
  const goalKey = personId + '_' + goal.id;
  const today = getDateStamp();
  const yesterday = getDateStamp(new Date(Date.now() - 86400000));
  
  // Safety check for goalState
  if (!app.goalState) {
    app.goalState = {streaks: {}, totals: {}, lastCompletionDate: {}, achievements: {}};
  }
  if (!app.goalState.streaks) app.goalState.streaks = {};
  if (!app.goalState.totals) app.goalState.totals = {};
  if (!app.goalState.lastCompletionDate) app.goalState.lastCompletionDate = {};
  if (!app.goalState.achievements) app.goalState.achievements = {};
  
  if (goal.type === 'streak' && pct >= 100) {
    if (app.goalState.lastCompletionDate[goalKey] === today) return;
    
    if (app.goalState.lastCompletionDate[goalKey] === yesterday) {
      app.goalState.streaks[goalKey] = (app.goalState.streaks[goalKey] || 0) + 1;
    } else {
      app.goalState.streaks[goalKey] = 1;
    }
    app.goalState.lastCompletionDate[goalKey] = today;
    await saveGoalState(app.goalState);
    
    checkGoalAchievement(personId, goal);
  } else if (goal.type === 'total' && pct >= 100) {
    if (app.goalState.lastCompletionDate[goalKey] !== today) {
      app.goalState.totals[goalKey] = (app.goalState.totals[goalKey] || 0) + 1;
      app.goalState.lastCompletionDate[goalKey] = today;
      await saveGoalState(app.goalState);
      
      checkGoalAchievement(personId, goal);
    }
  }
}

function checkGoalAchievement(personId, goal) {
  const progress = getGoalProgress(personId, goal);
  const goalKey = personId + '_' + goal.id;
  
  // Safety check for goalState
  if (!app.goalState) {
    app.goalState = {streaks: {}, totals: {}, lastCompletionDate: {}, achievements: {}};
  }
  if (!app.goalState.achievements) app.goalState.achievements = {};
  
  if (progress.current >= progress.target && !app.goalState.achievements[goalKey]) {
    app.goalState.achievements[goalKey] = getDateStamp();
    saveGoalState(app.goalState);
    showGoalNotification(personId, goal);
  }
}

function showGoalNotification(personId, goal) {
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return;
  
  const notification = document.createElement('div');
  notification.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,#fbbf24,#f59e0b);color:white;padding:24px 32px;border-radius:16px;font-size:18px;font-weight:bold;text-align:center;z-index:1001;box-shadow:0 20px 60px rgba(0,0,0,.5)';
  notification.innerHTML = `<div style="font-size:32px;margin-bottom:8px">🎉 🏆 🎉</div><div>Goal Achieved!</div><div style="margin-top:8px">${escapeHtml(person.name)}: ${escapeHtml(goal.name)}</div>`;
  
  document.body.appendChild(notification);
  setTimeout(() => {
    notification.style.opacity = '0';
    notification.style.transition = 'opacity 0.3s';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

function confirmDialog(message) {
  return new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.className = 'modal-backdrop';
    overlay.innerHTML = `
      <div class="modal" role="dialog" aria-modal="true">
        <div class="modal-body">${escapeHtml(message)}</div>
        <div class="row" style="justify-content:flex-end">
          <button class="btn small ghost" id="modalNo">Cancel</button>
          <button class="btn small" id="modalYes">Confirm</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    const yes = overlay.querySelector('#modalYes');
    const no = overlay.querySelector('#modalNo');
    
    const cleanup = v => {
      overlay.remove();
      resolve(v);
    };
    
    yes.onclick = () => cleanup(true);
    no.onclick = () => cleanup(false);
    overlay.onclick = e => {
      if (e.target === overlay) cleanup(false);
    };
    
    setTimeout(() => yes.focus(), 0);
  });
}

function openPetCustomizer(person) {
  return new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.className = 'modal-backdrop';
    
    const currentPetName = person.petName || 'Pet';
    const currentPetEmoji = person.petEmoji || '😄';
    
    const petOptions = ['😄', '😊', '🐶', '🐱', '🐼', '🐰', '🦊', '🐻', '🐨', '🦁', '🐯', '🐸', '🐵', '🦄', '🐲', '🦖'];
    
    overlay.innerHTML = `
      <div class="modal" role="dialog" aria-modal="true">
        <div class="modal-body">
          <h3 style="margin:0 0 16px 0">Customize ${escapeHtml(person.name)}'s Pet</h3>
          
          <div class="field" style="margin-bottom:16px">
            <label>Pet Name</label>
            <input id="petNameInput" type="text" value="${escapeHtml(currentPetName)}" placeholder="Enter pet name" style="width:100%;margin-top:8px"/>
          </div>
          
          <div class="field">
            <label>Choose Pet</label>
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px">
              ${petOptions.map(emoji => `
                <button class="pet-option ${emoji === currentPetEmoji ? 'selected' : ''}" data-emoji="${emoji}" 
                  style="font-size:32px;padding:12px;border:2px solid ${emoji === currentPetEmoji ? 'var(--accent)' : 'var(--outline)'};
                  border-radius:12px;background:var(--card);cursor:pointer;transition:all 0.2s">
                  ${emoji}
                </button>
              `).join('')}
            </div>
          </div>
        </div>
        <div class="row" style="justify-content:flex-end">
          <button class="btn small ghost" id="petCancel">Cancel</button>
          <button class="btn small" id="petSave">Save</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    
    let selectedEmoji = currentPetEmoji;
    
    overlay.querySelectorAll('.pet-option').forEach(btn => {
      btn.onclick = () => {
        overlay.querySelectorAll('.pet-option').forEach(b => {
          b.style.borderColor = 'var(--outline)';
          b.classList.remove('selected');
        });
        btn.style.borderColor = 'var(--accent)';
        btn.classList.add('selected');
        selectedEmoji = btn.dataset.emoji;
      };
    });
    
    const cleanup = () => {
      overlay.remove();
      resolve();
    };
    
    overlay.querySelector('#petSave').onclick = async () => {
      const petName = overlay.querySelector('#petNameInput').value.trim() || 'Pet';
      
      // Update person's pet data
      person.petName = petName;
      person.petEmoji = selectedEmoji;
      
      // Save to config
      app.CONFIG.people = app.PEOPLE;
      await saveConfig(app.CONFIG);
      
      cleanup();
      openDetail(person.id);
    };
    
    overlay.querySelector('#petCancel').onclick = cleanup;
    overlay.onclick = e => {
      if (e.target === overlay) cleanup();
    };
  });
}

async function renderIndividualAnalytics(person) {
  const container = document.getElementById('individualAnalytics');
  if (!container) return;
  
  // Get last 7 days of data
  const history = await getHistoricalData(7);
  
  const personHistory = history.map(day => {
    const personData = day.people[person.id];
    if (!personData) return {date: day.date, pct: 0, total: 0, done: 0};
    const pct = personData.total > 0 ? Math.round((personData.done / personData.total) * 100) : 0;
    return {date: day.date, pct, total: personData.total, done: personData.done};
  });
  
  const avg = Math.round(personHistory.reduce((a, b) => a + b.pct, 0) / personHistory.length);
  const bestDay = Math.max(...personHistory.map(d => d.pct));
  const perfectDays = personHistory.filter(d => d.pct === 100).length;
  
  // Create bar chart
  const bars = personHistory.map((day, i) => {
    const height = Math.max(day.pct, 5);
    const color = day.pct >= 71 ? '#22c55e' : day.pct >= 41 ? '#f59e0b' : '#94a3b8';
    const date = new Date(day.date);
    const dayName = date.toLocaleDateString('en-US', {weekday: 'short'});
    
    return `<div style="flex:1;display:flex;flex-direction:column;align-items:center;gap:4px">
      <div style="height:100px;display:flex;align-items:flex-end">
        <div style="width:100%;height:${height}%;background:${color};border-radius:4px 4px 0 0" 
          title="${dayName}: ${day.pct}% (${day.done}/${day.total})"></div>
      </div>
      <div class="muted" style="font-size:10px">${dayName}</div>
      <div style="font-size:11px;font-weight:600">${day.pct}%</div>
    </div>`;
  }).join('');
  
  container.innerHTML = `
    <div style="display:flex;gap:2px;margin-bottom:16px">${bars}</div>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;text-align:center">
      <div>
        <div style="font-size:24px;font-weight:700;color:var(--accent)">${avg}%</div>
        <div class="muted" style="font-size:12px">Avg This Week</div>
      </div>
      <div>
        <div style="font-size:24px;font-weight:700;color:#22c55e">${bestDay}%</div>
        <div class="muted" style="font-size:12px">Best Day</div>
      </div>
      <div>
        <div style="font-size:24px;font-weight:700;color:#fbbf24">${perfectDays}</div>
        <div class="muted" style="font-size:12px">Perfect Days</div>
      </div>
    </div>
  `;
}

function pinDialog() {
  return new Promise(resolve => {
    const overlay = document.createElement('div');
    overlay.className = 'modal-backdrop';
    const hintHtml = app.CONFIG.pinHint ? `<div class="muted" style="margin-top:4px">Hint: ${escapeHtml(app.CONFIG.pinHint)}</div>` : '';
    
    overlay.innerHTML = `
      <div class="modal" role="dialog" aria-modal="true">
        <div class="modal-body">
          <div class="field">
            <label>Enter PIN to access settings</label>
            <input id="pinInput" type="password" placeholder="Enter PIN" style="width:100%;margin-top:8px"/>
            ${hintHtml}
          </div>
          <div class="field hidden" id="recoveryField" style="margin-top:12px">
            <label>Or enter recovery phrase</label>
            <input id="recoveryInput" type="text" placeholder="Recovery phrase" style="width:100%;margin-top:8px"/>
          </div>
          <div id="pinError" style="color:#f87171;font-size:12px;margin-top:8px"></div>
        </div>
        <div class="row" style="justify-content:space-between">
          <button class="btn small ghost" id="forgotBtn">Forgot?</button>
          <div class="row">
            <button class="btn small ghost" id="pinCancel">Cancel</button>
            <button class="btn small" id="pinOK">Unlock</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    const pinInput = overlay.querySelector('#pinInput');
    const recoveryInput = overlay.querySelector('#recoveryInput');
    const recoveryField = overlay.querySelector('#recoveryField');
    const errorEl = overlay.querySelector('#pinError');
    const forgotBtn = overlay.querySelector('#forgotBtn');
    
    forgotBtn.onclick = () => {
      recoveryField.classList.toggle('hidden');
      if (!recoveryField.classList.contains('hidden')) {
        recoveryInput.focus();
      }
    };
    
    const cleanup = v => {
      overlay.remove();
      resolve(v);
    };
    
    const checkPin = () => {
      const pin = pinInput.value.trim();
      const recovery = recoveryInput.value.trim();
      
      if (pin && app.CONFIG.pinHash) {
        const testHash = hashPin(pin, app.CONFIG.pinSalt || '');
        if (testHash === app.CONFIG.pinHash) {
          cleanup(true);
          return;
        }
        errorEl.textContent = 'Incorrect PIN';
        return;
      }
      
      if (recovery && app.CONFIG.recoveryPhrase) {
        if (recovery === app.CONFIG.recoveryPhrase) {
          cleanup(true);
          return;
        }
        errorEl.textContent = 'Incorrect recovery phrase';
        return;
      }
      
      errorEl.textContent = 'Please enter PIN or recovery phrase';
    };
    
    overlay.querySelector('#pinOK').onclick = checkPin;
    overlay.querySelector('#pinCancel').onclick = () => cleanup(false);
    
    pinInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') checkPin();
    });
    
    recoveryInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') checkPin();
    });
    
    setTimeout(() => pinInput.focus(), 0);
  });
}

function deriveNowNext(tasks, nowMins) {
  const timed = tasks.map(t => ({t, time: getTaskTime(t)}))
    .filter(x => !!x.time)
    .sort((a, b) => minutesOf(a.time) - minutesOf(b.time));
  
  if (timed.length === 0) return {now: null, next: null};
  
  for (let i = 0; i < timed.length; i++) {
    const cur = timed[i], nxt = timed[i + 1];
    const curStart = minutesOf(cur.time);
    const curEnd = curStart + 30; // Task window is task time + 30 minutes
    const nextStart = nxt ? minutesOf(nxt.time) : Infinity;
    
    if (nowMins < curStart) {
      // Before the first task
      return {now: null, next: {task: cur.t, label: cur.t.label, time: cur.time}};
    }
    if (nowMins >= curStart && nowMins < curEnd && nowMins < nextStart) {
      // Within current task window and before next task
      return {
        now: {task: cur.t, label: cur.t.label, time: cur.time},
        next: nxt ? {task: nxt.t, label: nxt.t.label, time: nxt.time} : null
      };
    }
    if (nowMins >= curEnd && (nowMins < nextStart || !nxt)) {
      // After current task window
      if (nxt && nowMins < nextStart) {
        // Free time between tasks
        return {now: null, next: {task: nxt.t, label: nxt.t.label, time: nxt.time}};
      } else if (!nxt) {
        // After all tasks
        return {now: null, next: null};
      }
    }
  }
  
  return {now: null, next: null};
}

function isTaskOverdue(personId, t, nowMins) {
  const tm = getTaskTime(t);
  if (!tm) return false;
  if (isChecked(personId, t.id)) return false;
  if (isSkipped(personId, t.id)) return false;
  return nowMins >= minutesOf(tm) + 30;
}

function overdueCountForPerson(p, nowMins) {
  if (!p.tasks || !Array.isArray(p.tasks)) return 0;
  let c = 0;
  for (const t of p.tasks) {
    if (isTaskOverdue(p.id, t, nowMins)) c++;
  }
  return c;
}

function incompleteCountForPerson(p) {
  if (!p.tasks || !Array.isArray(p.tasks)) return 0;
  const nowM = nowMinutes();
  let c = 0;
  for (const t of p.tasks) {
    // Only count as incomplete if task is overdue (30+ mins past due time) and not completed/skipped
    if (!isChecked(p.id, t.id) && !isOverdueCompleted(p.id, t.id) && !isSkipped(p.id, t.id)) {
      const tm = getTaskTime(t);
      if (tm && nowM >= minutesOf(tm) + 30) {
        c++;
      }
    }
  }
  return c;
}

function overdueCompletedCountForPerson(p) {
  if (!p.tasks || !Array.isArray(p.tasks)) return 0;
  let c = 0;
  for (const t of p.tasks) {
    if (isOverdueCompleted(p.id, t.id)) c++;
  }
  return c;
}

function skippedCountForPerson(p) {
  if (!p.tasks || !Array.isArray(p.tasks)) return 0;
  let c = 0;
  for (const t of p.tasks) {
    if (isSkipped(p.id, t.id)) c++;
  }
  return c;
}

function overallCounts() {
  let total = 0, done = 0;
  app.PEOPLE.forEach(p => {
    // Ensure tasks array exists
    if (!p.tasks || !Array.isArray(p.tasks)) {
      p.tasks = [];
    }
    total += p.tasks.length;
    done += p.tasks.filter(t => isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id)).length;
  });
  const pct = total ? (done / total * 100) : 0;
  return {done, total, pct};
}

async function renderDashboard() {
  app.CURRENT_PERSON = null;
  app.dom.summaryEl.classList.add('hidden');
  app.dom.detailEl.classList.add('hidden');
  app.dom.editorEl.classList.add('hidden');
  app.dom.dashboardEl.classList.remove('hidden');
  
  // Safety check
  if (!app.PEOPLE || !Array.isArray(app.PEOPLE)) {
    app.PEOPLE = [];
  }
  
  // Get historical data for last 30 days
  const history = await getHistoricalData(30);
  
  // Calculate current week stats
  const weekHistory = history.slice(-7);
  const weekTotal = weekHistory.reduce((sum, day) => sum + day.total, 0);
  const weekDone = weekHistory.reduce((sum, day) => sum + day.done, 0);
  const weekPct = weekTotal > 0 ? Math.round((weekDone / weekTotal) * 100) : 0;
  
  // Calculate streaks
  const streak = calculateStreak(history);
  
  app.dom.dashboardEl.innerHTML = `
    <div class="card" style="margin-bottom:16px">
      <button class="btn small ghost" id="backFromDashboard">← Back to Home</button>
    </div>
    
    <!-- Hero Section -->
    <div class="card" style="margin-bottom:16px">
      <h2 style="margin:0 0 16px 0">This Week's Progress</h2>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-bottom:16px">
        <div style="text-align:center">
          <div style="font-size:64px;font-weight:800;color:var(--accent)">${weekPct}%</div>
          <div class="muted">Week Completion</div>
        </div>
        <div style="text-align:center">
          <div style="font-size:64px">🔥</div>
          <div style="font-size:24px;font-weight:700">${streak.current} ${streak.current === 1 ? 'day' : 'days'}</div>
          <div class="muted">Current Streak</div>
        </div>
        <div style="text-align:center">
          <div style="font-size:64px">🏆</div>
          <div style="font-size:24px;font-weight:700">${streak.best} ${streak.best === 1 ? 'day' : 'days'}</div>
          <div class="muted">Best Streak</div>
        </div>
      </div>
      
      <h3 style="margin:16px 0 12px 0">Family Pet Status</h3>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px">
        ${app.PEOPLE.map(p => {
          // Calculate completion excluding skipped tasks to match main page
          const nonSkippedTasks = (p.tasks || []).filter(t => !isSkipped(p.id, t.id));
          const total = nonSkippedTasks.length;
          const done = nonSkippedTasks.filter(t => isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id)).length;
          const pct = total > 0 ? Math.round((done / total) * 100) : 100;
          const nowM = nowMinutes();
          const pet = getPetState(pct, p, nowM);
          const petEmoji = p.petEmoji || pet.emoji;
          return `
            <div style="text-align:center;padding:12px;border:1px solid var(--outline);border-radius:12px">
              <div class="pet-container">
                <div style="font-size:48px;margin-bottom:8px">${petEmoji}</div>
                <div class="mood-indicator">${pet.indicator}</div>
              </div>
              <div style="font-weight:600;margin-bottom:4px">${escapeHtml(p.name)}</div>
              <div class="muted" style="font-size:11px;color:${pet.color}">${pet.state}</div>
              <div style="margin-top:8px;font-size:14px">${pct}%</div>
            </div>
          `;
        }).join('')}
      </div>
    </div>
    
    <!-- Calendar Heat Map -->
    <div class="card" style="margin-bottom:16px">
      <h2 style="margin:0 0 16px 0">Last 30 Days</h2>
      <div id="heatMap" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(30px,1fr));gap:4px"></div>
      <div style="display:flex;justify-content:center;gap:8px;margin-top:12px;font-size:11px">
        <span class="muted">Less</span>
        <div style="width:15px;height:15px;background:#94a3b8;border-radius:3px"></div>
        <div style="width:15px;height:15px;background:#f59e0b;border-radius:3px"></div>
        <div style="width:15px;height:15px;background:#22c55e;border-radius:3px"></div>
        <span class="muted">More</span>
      </div>
    </div>
    
    <!-- Individual Performance -->
    <div class="card" style="margin-bottom:16px">
      <h2 style="margin:0 0 16px 0">Individual Trends (7 Days)</h2>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px">
        ${app.PEOPLE.map(p => renderPersonTrendCard(p, weekHistory)).join('')}
      </div>
    </div>
    
    <!-- Task Completion Analysis -->
    <div class="card" style="margin-bottom:16px">
      <h2 style="margin:0 0 16px 0">Task Completion Analysis (This Week)</h2>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:16px">
        ${app.PEOPLE.map(p => renderPersonCompletionAnalysis(p)).join('')}
      </div>
    </div>
    
    <!-- Forgiveness Tool -->
    <div class="card" style="margin-bottom:16px">
      <h2 style="margin:0 0 8px 0">Forgive Tasks</h2>
      <p class="muted" style="font-size:13px;margin:0 0 16px 0">Clear overdue or incomplete tasks when there are special circumstances</p>
      <button class="btn" id="openForgivenessBtn" style="width:100%">Open Forgiveness Tool</button>
    </div>
    
    <!-- Achievements -->
    <div class="card">
      <h2 style="margin:0 0 16px 0">Recent Achievements</h2>
      <div id="achievementsList"></div>
    </div>
  `;
  
  // Render heat map
  renderHeatMap(history);
  
  // Render achievements
  renderAchievements();
  
  document.getElementById('backFromDashboard').onclick = renderSummary;
  
  document.getElementById('openForgivenessBtn').onclick = async () => {
    // Check PIN protection
    if (app.CONFIG.pinEnabled && Date.now() >= app.AUTH_UNTIL) {
      const unlocked = await pinDialog();
      if (!unlocked) return;
      app.AUTH_UNTIL = Date.now() + (5 * 60 * 1000);
    }
    openForgivenessDialog();
  };
  
  applyColorTheme(app.CONFIG.colorTheme || 'blue');
}

function renderPersonCompletionAnalysis(person) {
  // Get this week's task completion data
  const onTime = (person.tasks || []).filter(t => isChecked(person.id, t.id)).length;
  const overdue = (person.tasks || []).filter(t => isOverdueCompleted(person.id, t.id)).length;
  const incomplete = incompleteCountForPerson(person);
  const total = (person.tasks || []).length;
  
  const onTimePct = total > 0 ? Math.round((onTime / total) * 100) : 0;
  const overduePct = total > 0 ? Math.round((overdue / total) * 100) : 0;
  const incompletePct = total > 0 ? Math.round((incomplete / total) * 100) : 0;
  
  return `
    <div class="card clickable" style="border:1px solid var(--outline);border-radius:12px;padding:16px" onclick="showTaskDetails('${person.id}')">
      <div style="font-weight:600;margin-bottom:16px">${escapeHtml(person.name)}</div>
      
      <div style="margin-bottom:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
          <span style="font-size:13px">✅ On Time</span>
          <span style="font-weight:600;color:#22c55e">${onTime} (${onTimePct}%)</span>
        </div>
        <div style="height:8px;background:rgba(34,197,94,.2);border-radius:4px;overflow:hidden">
          <div style="height:100%;width:${onTimePct}%;background:#22c55e"></div>
        </div>
      </div>
      
      <div style="margin-bottom:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
          <span style="font-size:13px">⚠️ Overdue</span>
          <span style="font-weight:600;color:#f59e0b">${overdue} (${overduePct}%)</span>
        </div>
        <div style="height:8px;background:rgba(245,158,11,.2);border-radius:4px;overflow:hidden">
          <div style="height:100%;width:${overduePct}%;background:#f59e0b"></div>
        </div>
      </div>
      
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">
          <span style="font-size:13px">❌ Incomplete</span>
          <span style="font-weight:600;color:#ef4444">${incomplete} (${incompletePct}%)</span>
        </div>
        <div style="height:8px;background:rgba(239,68,68,.2);border-radius:4px;overflow:hidden">
          <div style="height:100%;width:${incompletePct}%;background:#ef4444"></div>
        </div>
      </div>
      
      <div class="muted" style="font-size:11px;margin-top:12px;text-align:center">Click for task details</div>
    </div>
  `;
}

function openForgivenessDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  
  const peopleButtons = app.PEOPLE.map(p => {
    const nowM = nowMinutes();
    const overdueCount = (p.tasks || []).filter(t => isOverdueCompleted(p.id, t.id)).length;
    const incompleteCount = incompleteCountForPerson(p);
    const totalIssues = overdueCount + incompleteCount;
    
    return `
      <button class="btn" style="width:100%;margin-bottom:8px;text-align:left;display:flex;justify-content:space-between;align-items:center" 
        onclick="showForgiveOptions('${p.id}')">
        <span>${escapeHtml(p.name)}</span>
        <span class="pill ${totalIssues > 0 ? 'danger' : 'success'}">${totalIssues} issues</span>
      </button>
    `;
  }).join('');
  
  overlay.innerHTML = `
    <div class="modal" role="dialog" aria-modal="true" style="max-width:500px;max-height:90vh;display:flex;flex-direction:column">
      <h3 style="margin:0 0 16px 0">Forgive Tasks</h3>
      <p class="muted" style="font-size:13px;margin-bottom:16px">Select a family member to forgive their overdue or incomplete tasks</p>
      <div id="forgivenessContent" style="flex:1;overflow-y:auto;margin-bottom:16px">
        ${peopleButtons}
      </div>
      <div style="text-align:right">
        <button class="btn small ghost" id="closeForgiveness">Close</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  overlay.querySelector('#closeForgiveness').onclick = () => overlay.remove();
  overlay.onclick = e => {
    if (e.target === overlay) overlay.remove();
  };
  
  // Store reference for later use
  window.currentForgivenessOverlay = overlay;
}

window.showForgiveOptions = function(personId) {
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return;
  
  const nowM = nowMinutes();
  const overdueTasks = (person.tasks || []).filter(t => isOverdueCompleted(person.id, t.id));
  const incompleteTasks = (person.tasks || []).filter(t => {
    const tm = getTaskTime(t);
    return tm && nowM >= minutesOf(tm) + 30 && !isChecked(person.id, t.id) && !isOverdueCompleted(person.id, t.id) && !isSkipped(person.id, t.id);
  });
  
  const allProblems = [...overdueTasks, ...incompleteTasks];
  
  if (allProblems.length === 0) {
    const content = window.currentForgivenessOverlay.querySelector('#forgivenessContent');
    content.innerHTML = `
      <div style="text-align:center;padding:20px">
        <div style="font-size:48px;margin-bottom:12px">✨</div>
        <div style="font-weight:600;margin-bottom:8px">${escapeHtml(person.name)} has no issues!</div>
        <div class="muted" style="font-size:13px">All tasks are on track</div>
        <button class="btn small" style="margin-top:16px" onclick="location.reload()">Back</button>
      </div>
    `;
    return;
  }
  
  const groupedByPeriod = {
    morning: allProblems.filter(t => t.when === 'morning'),
    afternoon: allProblems.filter(t => t.when === 'afternoon'),
    evening: allProblems.filter(t => t.when === 'evening')
  };
  
  const content = window.currentForgivenessOverlay.querySelector('#forgivenessContent');
  content.innerHTML = `
    <div style="margin-bottom:16px">
      <button class="btn small ghost" onclick="openForgivenessDialog()">← Back to family</button>
    </div>
    
    <h4 style="margin:0 0 12px 0">${escapeHtml(person.name)}'s Issues</h4>
    
    <div style="margin-bottom:16px">
      <button class="btn" style="width:100%" onclick="forgiveAll('${person.id}')">
        Forgive All (${allProblems.length} tasks)
      </button>
    </div>
    
    <div style="border-top:1px solid var(--outline);padding-top:16px;margin-top:16px">
      <h5 style="margin:0 0 12px 0">Forgive by Period</h5>
      ${groupedByPeriod.morning.length > 0 ? `
        <button class="btn ghost" style="width:100%;margin-bottom:8px" onclick="forgivePeriod('${person.id}', 'morning')">
          Morning (${groupedByPeriod.morning.length} tasks)
        </button>
      ` : ''}
      ${groupedByPeriod.afternoon.length > 0 ? `
        <button class="btn ghost" style="width:100%;margin-bottom:8px" onclick="forgivePeriod('${person.id}', 'afternoon')">
          Afternoon (${groupedByPeriod.afternoon.length} tasks)
        </button>
      ` : ''}
      ${groupedByPeriod.evening.length > 0 ? `
        <button class="btn ghost" style="width:100%;margin-bottom:8px" onclick="forgivePeriod('${person.id}', 'evening')">
          Evening (${groupedByPeriod.evening.length} tasks)
        </button>
      ` : ''}
    </div>
    
    <div style="border-top:1px solid var(--outline);padding-top:16px;margin-top:16px">
      <h5 style="margin:0 0 12px 0">Forgive Individual Tasks</h5>
      ${allProblems.map(task => {
        const isOverdue = isOverdueCompleted(person.id, task.id);
        const badge = isOverdue ? '⚠️ Overdue' : '❌ Incomplete';
        return `
          <div style="display:flex;justify-content:space-between;align-items:center;padding:8px;border:1px solid var(--outline);border-radius:8px;margin-bottom:8px">
            <div style="flex:1">
              <div style="font-size:14px">${escapeHtml(stripLeadingTime(task.label))}</div>
              <div class="muted" style="font-size:11px">${badge}</div>
            </div>
            <button class="btn small" onclick="forgiveTask('${person.id}', '${task.id}')">Forgive</button>
          </div>
        `;
      }).join('')}
    </div>
  `;
};

window.forgiveAll = async function(personId) {
  if (!await confirmDialog('Forgive all overdue and incomplete tasks? This will clear their penalties.')) return;
  
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return;
  
  const nowM = nowMinutes();
  const allProblems = (person.tasks || []).filter(t => {
    return isOverdueCompleted(person.id, t.id) || 
      (() => {
        const tm = getTaskTime(t);
        return tm && nowM >= minutesOf(tm) + 30 && !isChecked(person.id, t.id) && !isOverdueCompleted(person.id, t.id) && !isSkipped(person.id, t.id);
      })();
  });
  
  for (const task of allProblems) {
    await setSkipped(person.id, task.id, true);
  }
  
  window.currentForgivenessOverlay.remove();
  renderDashboard();
};

window.forgivePeriod = async function(personId, period) {
  if (!await confirmDialog(`Forgive all ${period} tasks? This will clear their penalties.`)) return;
  
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return;
  
  const nowM = nowMinutes();
  const periodTasks = (person.tasks || []).filter(t => {
    if (t.when !== period) return false;
    return isOverdueCompleted(person.id, t.id) || 
      (() => {
        const tm = getTaskTime(t);
        return tm && nowM >= minutesOf(tm) + 30 && !isChecked(person.id, t.id) && !isOverdueCompleted(person.id, t.id) && !isSkipped(person.id, t.id);
      })();
  });
  
  for (const task of periodTasks) {
    await setSkipped(person.id, task.id, true);
  }
  
  window.currentForgivenessOverlay.remove();
  renderDashboard();
};

window.forgiveTask = async function(personId, taskId) {
  await setSkipped(personId, taskId, true);
  showForgiveOptions(personId);
};

function showTaskDetails(personId) {
  const person = app.PEOPLE.find(p => p.id === personId);
  if (!person) return;
  
  const nowM = nowMinutes();
  const taskStats = (person.tasks || []).map(task => {
    const onTime = isChecked(person.id, task.id);
    const overdue = isOverdueCompleted(person.id, task.id);
    const incomplete = !onTime && !overdue && !isSkipped(person.id, task.id) && 
      (() => {
        const tm = getTaskTime(task);
        return tm && nowM >= minutesOf(tm) + 30;
      })();
    
    let status = '✅ On Time';
    let color = '#22c55e';
    if (incomplete) {
      status = '❌ Incomplete';
      color = '#ef4444';
    } else if (overdue) {
      status = '⚠️ Completed Late';
      color = '#f59e0b';
    } else if (!onTime && !overdue && !incomplete) {
      status = '⏳ Pending';
      color = '#94a3b8';
    }
    
    return {task, status, color};
  });
  
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  overlay.innerHTML = `
    <div class="modal" role="dialog" aria-modal="true" style="max-width:600px">
      <h3 style="margin:0 0 16px 0">${escapeHtml(person.name)}'s Task Details</h3>
      <div style="max-height:400px;overflow-y:auto;margin-bottom:16px">
        ${taskStats.map(({task, status, color}) => `
          <div style="display:flex;justify-content:space-between;align-items:center;padding:12px;border:1px solid var(--outline);border-radius:8px;margin-bottom:8px">
            <div style="flex:1">
              <div style="font-weight:600;margin-bottom:4px">${escapeHtml(stripLeadingTime(task.label))}</div>
              ${task.time ? `<div class="muted" style="font-size:12px">${timeString12(task.time)}</div>` : ''}
            </div>
            <div style="font-size:13px;font-weight:600;color:${color};white-space:nowrap;margin-left:12px">
              ${status}
            </div>
          </div>
        `).join('')}
      </div>
      <div style="text-align:right">
        <button class="btn small" id="closeTaskDetails">Close</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  const closeBtn = overlay.querySelector('#closeTaskDetails');
  closeBtn.onclick = () => overlay.remove();
  overlay.onclick = e => {
    if (e.target === overlay) overlay.remove();
  };
}

function renderPersonTrendCard(person, weekHistory) {
  const personHistory = weekHistory.map(day => {
    const personData = day.people[person.id];
    return personData ? Math.round((personData.done / personData.total) * 100) : 0;
  });
  
  const avg = Math.round(personHistory.reduce((a, b) => a + b, 0) / personHistory.length);
  const bestDay = Math.max(...personHistory);
  
  // Create mini bar chart
  const bars = personHistory.map((pct, i) => {
    const height = Math.max(pct, 5); // Min height for visibility
    const color = pct >= 71 ? '#22c55e' : pct >= 41 ? '#f59e0b' : '#94a3b8';
    return `<div style="flex:1;display:flex;flex-direction:column;align-items:center;gap:4px">
      <div style="height:80px;display:flex;align-items:flex-end">
        <div style="width:100%;height:${height}%;background:${color};border-radius:4px 4px 0 0"></div>
      </div>
      <div class="muted" style="font-size:10px">${['S','M','T','W','T','F','S'][i]}</div>
    </div>`;
  }).join('');
  
  return `
    <div style="border:1px solid var(--outline);border-radius:12px;padding:16px">
      <div style="font-weight:600;margin-bottom:12px">${escapeHtml(person.name)}</div>
      <div style="display:flex;gap:2px;margin-bottom:12px">${bars}</div>
      <div style="display:flex;justify-content:space-between;font-size:12px">
        <div><span class="muted">Avg:</span> <strong>${avg}%</strong></div>
        <div><span class="muted">Best:</span> <strong>${bestDay}%</strong></div>
      </div>
    </div>
  `;
}

function renderHeatMap(history) {
  const container = document.getElementById('heatMap');
  if (!container) return;
  
  history.forEach(day => {
    const pct = day.total > 0 ? (day.done / day.total) * 100 : 0;
    const color = pct >= 71 ? '#22c55e' : pct >= 41 ? '#f59e0b' : pct >= 1 ? '#94a3b8' : '#374151';
    
    const date = new Date(day.date);
    const dayName = date.toLocaleDateString('en-US', {weekday: 'short', month: 'short', day: 'numeric'});
    
    const cell = document.createElement('div');
    cell.style.cssText = `
      aspect-ratio:1;
      background:${color};
      border-radius:6px;
      cursor:pointer;
      transition:transform 0.2s;
    `;
    cell.title = `${dayName}: ${Math.round(pct)}%`;
    cell.onmouseenter = () => cell.style.transform = 'scale(1.1)';
    cell.onmouseleave = () => cell.style.transform = 'scale(1)';
    
    container.appendChild(cell);
  });
}

function renderAchievements() {
  const container = document.getElementById('achievementsList');
  if (!container) return;
  
  const achievements = [];
  
  // Check for perfect days
  if (app.goalState && app.goalState.achievements) {
    Object.entries(app.goalState.achievements).forEach(([key, date]) => {
      const [personId, goalId] = key.split('_');
      const person = app.PEOPLE.find(p => p.id === personId);
      const goal = person?.goals?.find(g => g.id === goalId);
      
      if (person && goal) {
        achievements.push({
          icon: '🏆',
          title: `${person.name} - ${goal.name}`,
          date: date,
          type: 'goal'
        });
      }
    });
  }
  
  if (achievements.length === 0) {
    container.innerHTML = '<div class="muted">Complete goals to earn achievements!</div>';
    return;
  }
  
  container.innerHTML = achievements.slice(-5).reverse().map(a => `
    <div style="display:flex;align-items:center;gap:12px;padding:12px;border:1px solid var(--outline);border-radius:12px;margin-bottom:8px">
      <div style="font-size:32px">${a.icon}</div>
      <div style="flex:1">
        <div style="font-weight:600">${escapeHtml(a.title)}</div>
        <div class="muted" style="font-size:11px">${a.date}</div>
      </div>
    </div>
  `).join('');
}

async function getHistoricalData(days) {
  // Get data from Firebase history or reconstruct from current state
  try {
    const snapshot = await get(ref(database, 'history'));
    let historyData = [];
    
    if (snapshot.exists()) {
      historyData = snapshot.val();
    }
    
    // Fill in missing days up to today
    const today = new Date();
    const result = [];
    
    for (let i = days - 1; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = getDateStamp(date);
      
      const existingData = historyData.find(d => d.date === dateStr);
      
      if (existingData) {
        result.push(existingData);
      } else if (i === 0) {
        // Today - calculate from current state
        let total = 0, done = 0;
        const people = {};
        
        app.PEOPLE.forEach(p => {
          const pTotal = (p.tasks || []).length;
          const pDone = (p.tasks || []).filter(t => isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id)).length;
          total += pTotal;
          done += pDone;
          people[p.id] = {total: pTotal, done: pDone};
        });
        
        result.push({date: dateStr, total, done, people});
      } else {
        // Past day with no data
        result.push({date: dateStr, total: 0, done: 0, people: {}});
      }
    }
    
    return result;
  } catch (error) {
    console.error('Error loading history:', error);
    return [];
  }
}

async function saveHistoricalSnapshot() {
  // Save today's completion to history
  const today = getDateStamp();
  let total = 0, done = 0;
  const people = {};
  
  app.PEOPLE.forEach(p => {
    const pTotal = (p.tasks || []).length;
    const pDone = (p.tasks || []).filter(t => isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id)).length;
    total += pTotal;
    done += pDone;
    people[p.id] = {total: pTotal, done: pDone};
  });
  
  try {
    const snapshot = await get(ref(database, 'history'));
    let history = snapshot.exists() ? snapshot.val() : [];
    
    // Remove today's entry if it exists
    history = history.filter(d => d.date !== today);
    
    // Add today
    history.push({date: today, total, done, people});
    
    // Keep only last 90 days
    if (history.length > 90) {
      history = history.slice(-90);
    }
    
    await set(ref(database, 'history'), history);
  } catch (error) {
    console.error('Error saving history:', error);
  }
}

function calculateStreak(history) {
  let current = 0;
  let best = 0;
  let tempStreak = 0;
  
  // Count backwards from today for current streak
  for (let i = history.length - 1; i >= 0; i--) {
    const day = history[i];
    const pct = day.total > 0 ? (day.done / day.total) * 100 : 0;
    
    if (pct >= 80) {
      if (i === history.length - 1 || current > 0) {
        current++;
      }
    } else if (i === history.length - 1) {
      break; // Today wasn't good enough, no current streak
    } else {
      break;
    }
  }
  
  // Find best streak in entire history
  for (const day of history) {
    const pct = day.total > 0 ? (day.done / day.total) * 100 : 0;
    
    if (pct >= 80) {
      tempStreak++;
      best = Math.max(best, tempStreak);
    } else {
      tempStreak = 0;
    }
  }
  
  return {current, best};
}

async function renderSummary() {
  app.CURRENT_PERSON = null;
  app.dom.editorEl.classList.add('hidden');
  app.dom.detailEl.classList.add('hidden');
  app.dom.dashboardEl.classList.add('hidden');
  app.dom.summaryEl.classList.remove('hidden');
  app.dom.summaryEl.innerHTML = '';
  
  // Safety check
  if (!app.PEOPLE || !Array.isArray(app.PEOPLE)) {
    app.PEOPLE = [];
  }
  
  const nowM = nowMinutes();
  
  // Remove auto-skip logic - just render current state
  
  app.PEOPLE.forEach(p => {
    // Ensure tasks array exists and filter by frequency
    if (!p.tasks || !Array.isArray(p.tasks)) {
      p.tasks = [];
    }
    const todaysTasks = p.tasks.filter(t => shouldShowTaskToday(t));
    
    // Calculate completion excluding skipped tasks
    const nonSkippedTasks = todaysTasks.filter(t => !isSkipped(p.id, t.id));
    const total = nonSkippedTasks.length;
    const done = nonSkippedTasks.filter(t => isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id)).length;
    const pct = total > 0 ? Math.round((done / total) * 100) : 100;
    const overdueDone = overdueCompletedCountForPerson(p);
    const incomplete = incompleteCountForPerson(p);
    const timing = deriveNowNext(todaysTasks, nowM);
    const nowChecked = timing.now && timing.now.task && isChecked(p.id, timing.now.task.id);
    const nowSkipped = timing.now && timing.now.task && isSkipped(p.id, timing.now.task.id);
    
    const pet = getPetState(pct, p, nowM);
    const petEmoji = p.petEmoji || pet.emoji;
    const petName = p.petName || 'Pet';
    
    const currentActivity = getCurrentActivity(p, nowM);
    let activityDisplay = '';
    if (currentActivity) {
      const endTime = timeString12(currentActivity.endTime);
      activityDisplay = ` - At ${escapeHtml(currentActivity.name)} Until ${endTime}`;
    }
    
    const nowLine = (!timing.now || nowChecked || nowSkipped) ? 'Free Time' : 
      (timeString12(timing.now.time) + ' – ' + escapeHtml(stripLeadingTime(timing.now.label)));
    
    const nextLine = timing.next ? 
      (timeString12(timing.next.time) + ' – ' + escapeHtml(stripLeadingTime(timing.next.label))) : '—';
    
    const card = document.createElement('div');
    card.className = 'card clickable';
    card.innerHTML = `
      <div class="person">
        <div style="width:100%;text-align:center">
          <div style="display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:8px">
            <div class="pet-container" style="position:relative">
              <div style="font-size:48px;line-height:1" title="${petName} is ${pet.state}">${petEmoji}</div>
              <div class="mood-indicator">${pet.indicator}</div>
            </div>
            <h2 style="margin:0">${escapeHtml(p.name)}${activityDisplay}</h2>
          </div>
          <div class="muted" style="font-size:11px;margin-bottom:8px;color:${pet.color}">${escapeHtml(petName)} ${pet.state}</div>
          <div class="row" style="justify-content:center">
            <span class="pill ${done === total && overdueDone === 0 ? 'success' : ''}">Completed: ${done}/${total}</span>
            <span class="pill ${overdueDone > 0 ? 'danger' : ''}">Overdue: ${overdueDone}</span>
            <span class="pill ${incomplete > 0 ? 'danger' : ''}">Incomplete: ${incomplete}</span>
          </div>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="muted">
        <div><strong>Now:</strong> ${nowLine}</div>
        <div><strong>Next:</strong> ${nextLine}</div>
      </div>
      <div class="spacer"></div>
      <div class="progress">
        <div class="bar" style="width:${pct}%"></div>
      </div>
    `;
    
    card.addEventListener('click', () => openDetail(p.id));
    app.dom.summaryEl.appendChild(card);
  });
  
  updateDayProgress();
  applyColorTheme(app.CONFIG.colorTheme || 'blue');
  
  // Reset inactivity timer when opening detail view
  if (window.resetInactivityTimer) {
    window.resetInactivityTimer();
  }
}

async function openDetail(personId) {
  app.CURRENT_PERSON = personId;
  const p = app.PEOPLE.find(x => x.id === personId);
  if (!p) return;
  
  // Ensure required arrays exist
  if (!p.tasks || !Array.isArray(p.tasks)) p.tasks = [];
  if (!p.goals || !Array.isArray(p.goals)) p.goals = [];
  
  app.dom.summaryEl.classList.add('hidden');
  app.dom.editorEl.classList.add('hidden');
  app.dom.dashboardEl.classList.add('hidden');
  app.dom.detailEl.classList.remove('hidden');
  
  const nowM = nowMinutes();
  
  // Remove auto-skip logic - just render current state
  
  // Calculate completion excluding skipped tasks
  const nonSkippedTasks = p.tasks.filter(t => !isSkipped(p.id, t.id));
  const total = nonSkippedTasks.length;
  const done = nonSkippedTasks.filter(t => isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id)).length;
  const pct = total > 0 ? Math.round((done / total) * 100) : 100;
  const overdueDone = overdueCompletedCountForPerson(p);
  
  const pet = getPetState(pct, p, nowM);
  const petName = p.petName || 'Pet';
  const petEmoji = p.petEmoji || pet.emoji;
  
  let goalsHtml = '';
  if (p.goals && p.goals.length > 0) {
    goalsHtml = '<h3 style="margin:16px 0 12px 0">Goals & Challenges</h3>';
    p.goals.forEach(goal => {
      const progress = getGoalProgress(p.id, goal);
      const goalPct = Math.round((progress.current / progress.target) * 100);
      // Safety check for achievements
      const achieved = app.goalState && app.goalState.achievements ? app.goalState.achievements[p.id + '_' + goal.id] : null;
      goalsHtml += `
        <div class="goal-section">
          <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:4px">
            <div><strong>${escapeHtml(goal.name)}</strong></div>
            <span class="goal-badge">${goal.type === 'streak' ? 'Streak' : 'Total'}: ${progress.current}/${progress.target}</span>
          </div>
          <div class="goal-progress-bar">
            <div class="bar" style="width:${Math.min(100, goalPct)}%"></div>
          </div>
          ${achieved ? '<div class="muted" style="font-size:11px">🏆 Achieved on ' + achieved + '</div>' : ''}
        </div>
      `;
    });
  }
  
  app.dom.detailEl.innerHTML = `
    <div class="card" style="margin-bottom:14px">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
        <div style="display:flex;align-items:center;gap:16px">
          <div style="text-align:center">
            <div class="pet-container" style="position:relative">
              <div style="font-size:64px;line-height:1">${petEmoji}</div>
              <div class="mood-indicator">${pet.indicator}</div>
            </div>
            <div class="muted" style="font-size:11px;color:${pet.color}">${escapeHtml(petName)} ${pet.state}</div>
          </div>
          <div>
            <h2 style="margin:0">${escapeHtml(p.name)}</h2>
            <div class="row" style="margin-top:8px">
              <span class="pill ${done === total && overdueDone === 0 ? 'success' : ''}">Completed: ${done}/${total}</span>
              <span class="pill ${overdueDone > 0 ? 'danger' : ''}">Overdue: ${overdueDone}</span>
              <span class="pill ${incompleteCountForPerson(p) > 0 ? 'danger' : ''}">Incomplete: ${incompleteCountForPerson(p)}</span>
            </div>
          </div>
        </div>
        <div class="row">
          <button class="btn small ghost" id="backBtn">Back</button>
          <button class="btn small ghost" id="customizePet">🎨 Pet</button>
          <button class="btn small" id="saveProgress">Save</button>
          <button class="btn small" id="clearPerson">Clear</button>
        </div>
      </div>
      <div class="progress">
        <div class="bar" style="width:${pct}%"></div>
      </div>
    </div>
    ${goalsHtml}
    <div id="tasks"></div>
    
    <!-- Individual Analytics -->
    <div class="card" style="margin-top:16px">
      <h3 style="margin:0 0 12px 0">${escapeHtml(p.name)}'s Weekly Progress</h3>
      <div id="individualAnalytics"></div>
    </div>
  `;
  
  document.getElementById('backBtn').onclick = renderSummary;
  document.getElementById('customizePet').onclick = () => openPetCustomizer(p);
  document.getElementById('saveProgress').onclick = async () => {
    const saveBtn = document.getElementById('saveProgress');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;
    
    console.log('=== SAVE BUTTON CLICKED ===');
    console.log('Current app.state before refresh:', JSON.stringify(app.state, null, 2));
    
    // Force a fresh read from Firebase to ensure we have latest state
    try {
      const snapshot = await get(ref(database, 'state'));
      if (snapshot.exists()) {
        const freshState = snapshot.val();
        console.log('Fresh state from Firebase:', JSON.stringify(freshState, null, 2));
        
        // Ensure all required properties exist
        if (!freshState.checked) freshState.checked = {};
        if (!freshState.skipped) freshState.skipped = {};
        if (!freshState.overdueCompleted) freshState.overdueCompleted = {};
        
        app.state = freshState;
        console.log('app.state after setting fresh state:', JSON.stringify(app.state, null, 2));
      }
    } catch (error) {
      console.error('Error refreshing state:', error);
    }
    
    saveBtn.textContent = 'Saved!';
    saveBtn.className = 'btn small saved';
    saveBtn.disabled = false;
    
    console.log('About to call openDetail with person:', p.id);
    // Re-render with fresh state
    openDetail(p.id);
    
    setTimeout(() => {
      saveBtn.textContent = originalText;
      saveBtn.className = 'btn small';
    }, 1000);
  };
  document.getElementById('clearPerson').onclick = async () => {
    await clearPerson(p.id);
    openDetail(p.id);
  };
  
  // Render individual analytics
  renderIndividualAnalytics(p);
  
  const tasksWrap = document.getElementById('tasks');
  const groups = groupByWhen(p.tasks.filter(t => shouldShowTaskToday(t)));
  
  ['morning', 'afternoon', 'evening'].forEach(when => {
    if (!(groups[when] && groups[when].length)) return;
    
    const section = document.createElement('div');
    section.className = 'card';
    const doneW = groups[when].filter(t => isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id)).length;
    section.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <h3 style="margin:0;text-transform:capitalize">${when}</h3>
        <span class="muted">${doneW}/${groups[when].length}</span>
      </div>
    `;
    
    groups[when].forEach(t => {
      const row = document.createElement('div');
      row.className = 'task';
      const tt = getTaskTime(t);
      const timeStr = tt ? (timeString12(tt) + ' – ') : '';
      const chk = isChecked(p.id, t.id) || isOverdueCompleted(p.id, t.id);
      const sk = isSkipped(p.id, t.id);
      
      const trackedGoals = (p.goals || []).filter(goal => {
        if (goal.trackAll) return true;
        if (goal.trackPeriod && goal.trackPeriod === t.when) return true;
        if (goal.taskIds && goal.taskIds.includes(t.id)) return true;
        return false;
      });
      const goalBadges = trackedGoals.map(g => 
        `<span class="goal-badge" style="font-size:10px;padding:2px 6px;margin-left:4px" title="Tracked by: ${escapeHtml(g.name)}">🎯 ${escapeHtml(g.name)}</span>`
      ).join('');
      
      row.innerHTML = `
        <label class="row" style="flex:1;align-items:flex-start">
          <input type="checkbox" ${chk ? 'checked' : ''}>
          <div class="label">
            ${timeStr}${escapeHtml(stripLeadingTime(t.label))}
            ${goalBadges}
            <div class="when">${when}</div>
          </div>
        </label>
      `;
      
      if (trackedGoals.length > 0) {
        row.style.borderLeft = '3px solid #fbbf24';
      }
      
      if (sk) row.classList.add('skipped');
      else if (isTaskOverdue(p.id, t, nowM)) row.classList.add('overdue');
      
      const cb = row.querySelector('input');
      cb.addEventListener('change', async () => {
        const wasChecked = cb.checked;
        cb.disabled = true; // Prevent rapid clicking
        
        const currentTime = nowMinutes();
        await setChecked(p.id, t.id, wasChecked, t, currentTime);
        if (wasChecked) await setSkipped(p.id, t.id, false);
        
        if (p.goals && p.goals.length > 0) {
          for (const goal of p.goals) {
            await updateGoalProgress(p.id, goal);
            await recalculateGoalProgress(p.id, goal);
          }
        }
        
        // Don't re-render manually - let Firebase listener handle it
        cb.disabled = false;
      });
      
      section.appendChild(row);
    });
    
    tasksWrap.appendChild(section);
  });
  
  updateDayProgress();
  applyColorTheme(app.CONFIG.colorTheme || 'blue');
}

function renderEditor() {
  app.dom.summaryEl.classList.add('hidden');
  app.dom.detailEl.classList.add('hidden');
  app.dom.dashboardEl.classList.add('hidden');
  app.dom.editorEl.classList.remove('hidden');
  
  // Safety check
  if (!app.PEOPLE || !Array.isArray(app.PEOPLE)) {
    app.PEOPLE = [];
  }
  
  const timeVal = tm => tm && typeof tm === 'object' ? pad2(tm.h) + ':' + pad2(tm.m) : '';
  
  app.dom.editorEl.innerHTML = `
    <div class="form-card">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div>
          <h2 style="margin:0">App Settings</h2>
          <div class="muted" style="font-size:11px;margin-top:4px">${APP_VERSION}</div>
        </div>
        <div class="row">
          <button class="btn small ghost" id="cancelEdit">Cancel</button>
          <button class="btn small" id="saveEdit">Save</button>
        </div>
      </div>
      <div class="form-row">
        <div class="field">
          <label for="appTitleInput">App title</label>
          <input id="appTitleInput" type="text" value="${escapeHtml(app.CONFIG.appTitle)}"/>
        </div>
        <div class="field">
          <label for="resetHourInput">Daily reset hour (0–23)</label>
          <input id="resetHourInput" type="number" min="0" max="23" value="${app.CONFIG.resetHour}"/>
        </div>
      </div>
      <div class="form-row">
        <div class="field">
          <label>PIN Required to Access Settings</label>
          <div class="toggle-switch ${app.CONFIG.pinEnabled ? 'active' : 'inactive'}" id="pinToggle">
            <div class="toggle-slider">${app.CONFIG.pinEnabled ? 'YES' : 'NO'}</div>
            <div class="toggle-labels">
              <div class="toggle-label no">NO</div>
              <div class="toggle-label yes">YES</div>
            </div>
          </div>
        </div>
        <div class="field">
          <label for="pinSetInput">Set/Change PIN</label>
          <input id="pinSetInput" type="password" placeholder="Enter new PIN (optional)"/>
        </div>
      </div>
      <div class="form-row">
        <div class="field">
          <label for="pinHintInput">PIN hint (optional)</label>
          <input id="pinHintInput" type="text" placeholder="e.g., Mom's birthday" value="${escapeHtml(app.CONFIG.pinHint || '')}"/>
        </div>
        <div class="field">
          <label for="recoveryPhraseInput">Recovery phrase (optional)</label>
          <input id="recoveryPhraseInput" type="text" placeholder="Secret phrase adults know" value="${escapeHtml(app.CONFIG.recoveryPhrase || '')}"/>
        </div>
      </div>
      ${app.CONFIG.pinEnabled ? '<div class="muted" style="font-size:11px;margin-top:4px">PIN protection is enabled. Use "Forgot?" during unlock to access recovery options.</div>' : ''}
      <div class="field">
        <label>Color Theme</label>
        <div class="color-themes" id="colorThemes"></div>
      </div>
    </div>
    
    <div class="form-card">
      <h2 style="margin:0 0 12px 0">Screensaver Settings</h2>
      <div class="form-row">
        <div class="field">
          <label>Screensaver</label>
          <div class="toggle-switch ${app.CONFIG.screensaverEnabled !== false ? 'active' : 'inactive'}" id="screensaverToggle">
            <div class="toggle-slider">${app.CONFIG.screensaverEnabled !== false ? 'ON' : 'OFF'}</div>
            <div class="toggle-labels">
              <div class="toggle-label no">OFF</div>
              <div class="toggle-label yes">ON</div>
            </div>
          </div>
        </div>
        <div class="field">
          <label for="screensaverTimeoutInput">Inactivity timeout (seconds)</label>
          <input id="screensaverTimeoutInput" type="number" min="30" max="3600" value="${app.CONFIG.screensaverTimeout || 300}"/>
        </div>
      </div>
      <div class="field">
        <label for="screensaverGenreInput">Content Type</label>
        <select id="screensaverGenreInput">
          <option value="all" ${(app.CONFIG.screensaverGenre || 'all') === 'all' ? 'selected' : ''}>All Content</option>
          <option value="verses" ${app.CONFIG.screensaverGenre === 'verses' ? 'selected' : ''}>Bible Verses Only</option>
          <option value="facts" ${app.CONFIG.screensaverGenre === 'facts' ? 'selected' : ''}>Facts Only</option>
          <option value="words" ${app.CONFIG.screensaverGenre === 'words' ? 'selected' : ''}>Words Only</option>
        </select>
      </div>
    </div>
    
    <div class="form-card">
      <h2 style="margin:0 0 12px 0">Family Settings</h2>
      <div class="form-row">
        <div class="field">
          <label for="familyWakeInput">Family Wake Up Time</label>
          <input id="familyWakeInput" type="time" value="${timeVal(app.CONFIG.wakeParent) || '06:00'}"/>
        </div>
        <div class="field">
          <label for="familyBedInput">Family Bedtime</label>
          <input id="familyBedInput" type="time" value="${timeVal(app.CONFIG.bedtimeKids) || '21:00'}"/>
        </div>
      </div>
      <div class="form-row">
        <div class="field">
          <label for="morningEndInput">Morning ends at</label>
          <input id="morningEndInput" type="time" value="${timeVal(app.CONFIG.morningEnd) || '12:00'}"/>
        </div>
        <div class="field">
          <label for="afternoonEndInput">Afternoon ends at</label>
          <input id="afternoonEndInput" type="time" value="${timeVal(app.CONFIG.afternoonEnd) || '17:00'}"/>
        </div>
      </div>
      <div class="muted" style="font-size:11px;margin-top:4px">
        Tasks are auto-assigned: Morning (before ${timeString12(app.CONFIG.morningEnd || {h:12,m:0})}), 
        Afternoon (before ${timeString12(app.CONFIG.afternoonEnd || {h:17,m:0})}), 
        Evening (after)
      </div>
    </div>
    
    <div class="form-card">
      <h2 style="margin:0 0 12px 0">Family Members</h2>
      <div id="membersWrap"></div>
    </div>
  `;
  
  const themesContainer = document.getElementById('colorThemes');
  Object.keys(COLOR_THEMES).forEach(themeKey => {
    const theme = COLOR_THEMES[themeKey];
    const option = document.createElement('div');
    option.className = 'theme-option' + (app.CONFIG.colorTheme === themeKey ? ' selected' : '');
    option.dataset.theme = themeKey;
    option.innerHTML = `
      <div class="theme-preview">
        <div class="c1" style="background:${theme.primary}"></div>
        <div class="c2" style="background:${theme.secondary}"></div>
      </div>
      <div class="theme-label">${theme.name}</div>
    `;
    option.onclick = () => {
      document.querySelectorAll('.theme-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
    };
    themesContainer.appendChild(option);
  });
  
  const wrap = app.dom.editorEl.querySelector('#membersWrap');
  
  app.PEOPLE.forEach(p => {
    const m = document.createElement('div');
    m.className = 'member-card';
    m.dataset.memberId = p.id;
    
    m.innerHTML = `
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:16px">
        <div class="field" style="flex:1">
          <label>Name</label>
          <input type="text" value="${escapeHtml(p.name)}" data-field="name"/>
        </div>
        <div class="row">
          <button class="btn small" data-action="saveMember">Save</button>
          <button class="btn small" data-action="removeMember">Remove</button>
        </div>
      </div>
      
      <div class="settings-section">
        <h3 style="margin:0 0 12px 0;font-size:14px">Schedule</h3>
        
        <div class="field" style="margin-bottom:12px">
          <label>Use Family Default Times</label>
          <div class="toggle-switch ${p.useDefaultTimes !== false ? 'active' : 'inactive'}" data-toggle="useDefaultTimes">
            <div class="toggle-slider">${p.useDefaultTimes !== false ? 'YES' : 'NO'}</div>
            <div class="toggle-labels">
              <div class="toggle-label no">NO</div>
              <div class="toggle-label yes">YES</div>
            </div>
          </div>
        </div>
        
        <div class="custom-times ${p.useDefaultTimes !== false ? 'hidden' : ''}" data-field="customTimesSection">
          <div class="form-row">
            <div class="field">
              <label>Wake Time</label>
              <input type="time" value="${timeVal(p.wakeTime) || '06:00'}" data-field="wakeTime"/>
            </div>
            <div class="field">
              <label>Bedtime</label>
              <input type="time" value="${timeVal(p.bedTime) || '21:00'}" data-field="bedTime"/>
            </div>
          </div>
        </div>
      </div>
      
      <div class="settings-section">
        <h3 style="margin:0 0 12px 0;font-size:14px">Activities</h3>
        <div class="activities-list"></div>
        <button class="btn small" data-action="addActivity">Add Activity</button>
      </div>
      
      <div class="settings-section">
        <h3 style="margin:0 0 12px 0;font-size:14px">Goals</h3>
        <div class="goals-list"></div>
        <button class="btn small" data-action="addGoal">Add Goal</button>
      </div>
      
      <div class="settings-section">
        <h3 style="margin:0 0 12px 0;font-size:14px">Tasks</h3>
        <div class="tasks"></div>
        <button class="btn small" data-action="addTask">Add Task</button>
      </div>
    `;
    
    const goalsEl = m.querySelector('.goals-list');
    // Ensure goals array exists
    if (!p.goals || !Array.isArray(p.goals)) {
      p.goals = [];
    }
    (p.goals || []).forEach(goal => {
      goalsEl.appendChild(createGoalRow(goal, p));
    });
    
    m.querySelector('[data-action="addGoal"]').onclick = () => {
      goalsEl.appendChild(createGoalRow({
        id: uid('goal'),
        name: '',
        type: 'streak',
        target: 7,
        trackAll: true,
        trackPeriod: null,
        taskIds: []
      }, p));
    };
    
    const activitiesEl = m.querySelector('.activities-list');
    // Ensure activities array exists
    if (!p.activities || !Array.isArray(p.activities)) {
      p.activities = [];
    }
    (p.activities || []).forEach(activity => {
      activitiesEl.appendChild(createActivityRow(activity));
    });
    
    m.querySelector('[data-action="addActivity"]').onclick = () => {
      activitiesEl.appendChild(createActivityRow({
        id: uid('activity'),
        name: '',
        schedule: 'everyday',
        days: [],
        startTime: {h: 16, m: 0},
        endTime: {h: 17, m: 0}
      }));
    };
    
    const tasksEl = m.querySelector('.tasks');
    // Ensure tasks array exists
    if (!p.tasks || !Array.isArray(p.tasks)) {
      p.tasks = [];
    }
    p.tasks.forEach(t => tasksEl.appendChild(createTaskRow(t)));
    
    m.querySelector('[data-action="addTask"]').onclick = () => {
      tasksEl.appendChild(createTaskRow({id: uid('t'), label: '', when: 'morning'}));
    };
    
    m.querySelector('[data-action="removeMember"]').onclick = async () => {
      if (await confirmDialog('Remove ' + p.name + ' and all their tasks?')) {
        await clearPerson(p.id);
        app.PEOPLE = app.PEOPLE.filter(x => x.id !== p.id);
        app.CONFIG.people = app.PEOPLE;
        await saveConfig(app.CONFIG);
        cleanupDeletedGoals();
        updateDayProgress();
        renderEditor();
      }
    };
    
    m.querySelector('[data-action="saveMember"]').onclick = () => saveEditor();
    
    const useDefaultToggle = m.querySelector('[data-toggle="useDefaultTimes"]');
    const customTimesSection = m.querySelector('[data-field="customTimesSection"]');
    
    useDefaultToggle.onclick = () => {
      const isActive = useDefaultToggle.classList.contains('active');
      if (isActive) {
        useDefaultToggle.classList.remove('active');
        useDefaultToggle.classList.add('inactive');
        useDefaultToggle.querySelector('.toggle-slider').textContent = 'NO';
        customTimesSection.classList.remove('hidden');
      } else {
        useDefaultToggle.classList.remove('inactive');
        useDefaultToggle.classList.add('active');
        useDefaultToggle.querySelector('.toggle-slider').textContent = 'YES';
        customTimesSection.classList.add('hidden');
      }
    };
    
    wrap.appendChild(m);
  });
  
  const addCard = document.createElement('div');
  addCard.className = 'member-card';
  addCard.style.textAlign = 'center';
  addCard.innerHTML = '<button class="btn" id="addMemberBtn">+ Add Member</button>';
  wrap.appendChild(addCard);
  
  document.getElementById('cancelEdit').onclick = renderSummary;
  document.getElementById('saveEdit').onclick = saveEditor;
  document.getElementById('addMemberBtn').onclick = () => {
    app.PEOPLE.push({
      id: uid('m'), 
      name: 'New Member',
      useDefaultTimes: true,
      wakeTime: {h: 6, m: 0},
      bedTime: {h: 21, m: 0},
      workSchoolStart: {h: 8, m: 0},
      workSchoolEnd: {h: 15, m: 0},
      activities: [],
      goals: [], 
      tasks: []
    });
    app.CONFIG.people = app.PEOPLE;
    saveConfig(app.CONFIG);
    renderEditor();
  };
  
  const pinToggle = document.getElementById('pinToggle');
  pinToggle.onclick = () => {
    const isActive = pinToggle.classList.contains('active');
    if (isActive) {
      pinToggle.classList.remove('active');
      pinToggle.classList.add('inactive');
      pinToggle.querySelector('.toggle-slider').textContent = 'NO';
    } else {
      pinToggle.classList.remove('inactive');
      pinToggle.classList.add('active');
      pinToggle.querySelector('.toggle-slider').textContent = 'YES';
    }
  };
  
  const screensaverToggle = document.getElementById('screensaverToggle');
  screensaverToggle.onclick = () => {
    const isActive = screensaverToggle.classList.contains('active');
    if (isActive) {
      screensaverToggle.classList.remove('active');
      screensaverToggle.classList.add('inactive');
      screensaverToggle.querySelector('.toggle-slider').textContent = 'OFF';
    } else {
      screensaverToggle.classList.remove('inactive');
      screensaverToggle.classList.add('active');
      screensaverToggle.querySelector('.toggle-slider').textContent = 'ON';
    }
  };
  
  applyColorTheme(app.CONFIG.colorTheme || 'blue');
}

function createGoalRow(goal, person) {
  const row = document.createElement('div');
  row.className = 'goal-row';
  row.dataset.goalId = goal.id || uid('goal');
  
  let trackingText;
  if (goal.trackAll) {
    trackingText = 'All tasks';
  } else if (goal.trackPeriod) {
    trackingText = goal.trackPeriod.charAt(0).toUpperCase() + goal.trackPeriod.slice(1) + ' tasks';
  } else {
    trackingText = `${(goal.taskIds || []).length} tasks`;
  }
  
  row.innerHTML = `
    <input type="text" placeholder="Goal name" value="${escapeHtml(goal.name || '')}" data-field="goalName" style="grid-column:1/-1;margin-bottom:8px"/>
    <select data-field="goalType" style="grid-column:1">
      <option value="streak" ${goal.type === 'streak' ? 'selected' : ''}>Streak</option>
      <option value="total" ${goal.type === 'total' ? 'selected' : ''}>Total</option>
    </select>
    <button class="btn small ghost" data-action="selectTasks" style="grid-column:2">${trackingText}</button>
    <input type="number" placeholder="Target" value="${goal.target || ''}" data-field="goalTarget" min="1" style="grid-column:3;width:100px"/>
    <button class="btn small" data-action="removeGoal" style="grid-column:5">Remove</button>
    <div class="task-selector hidden" data-field="taskSelector" style="grid-column:1/-1"></div>
  `;
  
  const selector = row.querySelector('[data-field="taskSelector"]');
  const selectBtn = row.querySelector('[data-action="selectTasks"]');
  
  selectBtn.onclick = () => {
    selector.classList.toggle('hidden');
    if (!selector.classList.contains('hidden')) {
      selector.innerHTML = `
        <label><input type="radio" name="track-${goal.id}" data-track="all" ${goal.trackAll ? 'checked' : ''}/> Track all tasks</label>
        <label><input type="radio" name="track-${goal.id}" data-track="period" ${goal.trackPeriod ? 'checked' : ''}/> Track by time period</label>
        <div class="period-selector hidden" data-field="periodSelector" style="margin-left:20px;margin-top:4px">
          <label><input type="radio" name="period-${goal.id}" value="morning" ${goal.trackPeriod === 'morning' ? 'checked' : ''}/> Morning</label>
          <label><input type="radio" name="period-${goal.id}" value="afternoon" ${goal.trackPeriod === 'afternoon' ? 'checked' : ''}/> Afternoon</label>
          <label><input type="radio" name="period-${goal.id}" value="evening" ${goal.trackPeriod === 'evening' ? 'checked' : ''}/> Evening</label>
        </div>
        <label><input type="radio" name="track-${goal.id}" data-track="specific" ${!goal.trackAll && !goal.trackPeriod ? 'checked' : ''}/> Track specific tasks</label>
        <div class="specific-tasks hidden" data-field="specificTasks" style="margin-left:20px;margin-top:4px"></div>
      `;
      
      const periodSelector = selector.querySelector('[data-field="periodSelector"]');
      const specificTasks = selector.querySelector('[data-field="specificTasks"]');
      
      person.tasks.forEach(t => {
        const checked = !goal.trackAll && !goal.trackPeriod && goal.taskIds && goal.taskIds.includes(t.id);
        specificTasks.innerHTML += `<label><input type="checkbox" data-task="${t.id}" ${checked ? 'checked' : ''}/> ${escapeHtml(t.label || 'Unnamed task')}</label>`;
      });
      
      if (goal.trackPeriod) {
        periodSelector.classList.remove('hidden');
      }
      if (!goal.trackAll && !goal.trackPeriod) {
        specificTasks.classList.remove('hidden');
      }
      
      const trackAllRadio = selector.querySelector('[data-track="all"]');
      const trackPeriodRadio = selector.querySelector('[data-track="period"]');
      const trackSpecificRadio = selector.querySelector('[data-track="specific"]');
      
      trackAllRadio.onchange = () => {
        periodSelector.classList.add('hidden');
        specificTasks.classList.add('hidden');
        selectBtn.textContent = 'All tasks';
      };
      
      trackPeriodRadio.onchange = () => {
        periodSelector.classList.remove('hidden');
        specificTasks.classList.add('hidden');
        const selectedPeriod = periodSelector.querySelector('input[type="radio"]:checked');
        if (selectedPeriod) {
          const period = selectedPeriod.value;
          selectBtn.textContent = period.charAt(0).toUpperCase() + period.slice(1) + ' tasks';
        } else {
          periodSelector.querySelector('input[value="morning"]').checked = true;
          selectBtn.textContent = 'Morning tasks';
        }
      };
      
      trackSpecificRadio.onchange = () => {
        periodSelector.classList.add('hidden');
        specificTasks.classList.remove('hidden');
        const taskCbs = specificTasks.querySelectorAll('[data-task]');
        const selectedCount = Array.from(taskCbs).filter(cb => cb.checked).length;
        selectBtn.textContent = `${selectedCount} tasks`;
      };
      
      periodSelector.querySelectorAll('input[type="radio"]').forEach(radio => {
        radio.onchange = () => {
          const period = radio.value;
          selectBtn.textContent = period.charAt(0).toUpperCase() + period.slice(1) + ' tasks';
        };
      });
      
      specificTasks.querySelectorAll('[data-task]').forEach(cb => {
        cb.onchange = () => {
          const taskCbs = specificTasks.querySelectorAll('[data-task]');
          const selectedCount = Array.from(taskCbs).filter(c => c.checked).length;
          selectBtn.textContent = `${selectedCount} tasks`;
        };
      });
    }
  };
  
  row.querySelector('[data-action="removeGoal"]').onclick = async () => {
    const goalName = row.querySelector('input[data-field="goalName"]').value.trim() || 'this goal';
    if (await confirmDialog('Remove "' + goalName + '"?')) {
      row.remove();
      saveEditor();
    }
  };
  
  return row;
}

function createActivityRow(activity) {
  const row = document.createElement('div');
  row.className = 'goal-row';
  row.dataset.activityId = activity.id || uid('activity');
  
  let scheduleText = 'Every day';
  if (activity.schedule === 'weekdays') scheduleText = 'Weekdays';
  else if (activity.schedule === 'weekends') scheduleText = 'Weekends';
  else if (activity.schedule === 'specific' && activity.days) scheduleText = `${activity.days.length} days`;
  
  row.innerHTML = `
    <input type="text" placeholder="Activity name" value="${escapeHtml(activity.name || '')}" data-field="activityName" style="grid-column:1/-1;margin-bottom:8px"/>
    <input type="time" value="${activity.startTime ? timeString24(activity.startTime) : '16:00'}" data-field="startTime" style="grid-column:1"/>
    <input type="time" value="${activity.endTime ? timeString24(activity.endTime) : '17:00'}" data-field="endTime" style="grid-column:2"/>
    <button class="btn small ghost" data-action="selectSchedule" style="grid-column:3">${scheduleText}</button>
    <button class="btn small" data-action="removeActivity" style="grid-column:5">Remove</button>
    <div class="task-selector hidden" data-field="scheduleSelector" style="grid-column:1/-1"></div>
  `;
  
  const selector = row.querySelector('[data-field="scheduleSelector"]');
  const selectBtn = row.querySelector('[data-action="selectSchedule"]');
  
  selectBtn.onclick = () => {
    selector.classList.toggle('hidden');
    if (!selector.classList.contains('hidden')) {
      selector.innerHTML = `
        <label><input type="radio" name="schedule-${activity.id}" value="everyday" ${activity.schedule === 'everyday' || !activity.schedule ? 'checked' : ''}/> Every day</label>
        <label><input type="radio" name="schedule-${activity.id}" value="weekdays" ${activity.schedule === 'weekdays' ? 'checked' : ''}/> Weekdays (Mon-Fri)</label>
        <label><input type="radio" name="schedule-${activity.id}" value="weekends" ${activity.schedule === 'weekends' ? 'checked' : ''}/> Weekends (Sat-Sun)</label>
        <label><input type="radio" name="schedule-${activity.id}" value="specific" ${activity.schedule === 'specific' ? 'checked' : ''}/> Specific days</label>
        <div class="specific-days hidden" data-field="specificDays" style="margin-left:20px;margin-top:4px">
          <label><input type="checkbox" value="0" ${activity.days && activity.days.includes(0) ? 'checked' : ''}/> Sunday</label>
          <label><input type="checkbox" value="1" ${activity.days && activity.days.includes(1) ? 'checked' : ''}/> Monday</label>
          <label><input type="checkbox" value="2" ${activity.days && activity.days.includes(2) ? 'checked' : ''}/> Tuesday</label>
          <label><input type="checkbox" value="3" ${activity.days && activity.days.includes(3) ? 'checked' : ''}/> Wednesday</label>
          <label><input type="checkbox" value="4" ${activity.days && activity.days.includes(4) ? 'checked' : ''}/> Thursday</label>
          <label><input type="checkbox" value="5" ${activity.days && activity.days.includes(5) ? 'checked' : ''}/> Friday</label>
          <label><input type="checkbox" value="6" ${activity.days && activity.days.includes(6) ? 'checked' : ''}/> Saturday</label>
        </div>
      `;
      
      const specificDays = selector.querySelector('[data-field="specificDays"]');
      
      if (activity.schedule === 'specific') {
        specificDays.classList.remove('hidden');
      }
      
      selector.querySelectorAll('input[type="radio"]').forEach(radio => {
        radio.onchange = () => {
          if (radio.value === 'specific') {
            specificDays.classList.remove('hidden');
            const checked = specificDays.querySelectorAll('input[type="checkbox"]:checked');
            selectBtn.textContent = checked.length > 0 ? `${checked.length} days` : 'Select days';
          } else {
            specificDays.classList.add('hidden');
            if (radio.value === 'everyday') selectBtn.textContent = 'Every day';
            else if (radio.value === 'weekdays') selectBtn.textContent = 'Weekdays';
            else if (radio.value === 'weekends') selectBtn.textContent = 'Weekends';
          }
        };
      });
      
      specificDays.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.onchange = () => {
          const checked = specificDays.querySelectorAll('input[type="checkbox"]:checked');
          selectBtn.textContent = checked.length > 0 ? `${checked.length} days` : 'Select days';
        };
      });
    }
  };
  
  row.querySelector('[data-action="removeActivity"]').onclick = async () => {
    const activityName = row.querySelector('input[data-field="activityName"]').value.trim() || 'this activity';
    if (await confirmDialog('Remove "' + activityName + '"?')) {
      row.remove();
      saveEditor();
    }
  };
  
  return row;
}

function timeString24(tm) {
  return pad2(tm.h) + ':' + pad2(tm.m);
}

function getCurrentActivity(person, nowM) {
  if (!person.activities || !Array.isArray(person.activities) || person.activities.length === 0) return null;
  
  const now = new Date();
  const dayOfWeek = now.getDay();
  
  for (const activity of person.activities) {
    let isScheduledToday = false;
    
    if (activity.schedule === 'everyday') {
      isScheduledToday = true;
    } else if (activity.schedule === 'weekdays' && dayOfWeek >= 1 && dayOfWeek <= 5) {
      isScheduledToday = true;
    } else if (activity.schedule === 'weekends' && (dayOfWeek === 0 || dayOfWeek === 6)) {
      isScheduledToday = true;
    } else if (activity.schedule === 'specific' && activity.days && activity.days.includes(dayOfWeek)) {
      isScheduledToday = true;
    }
    
    if (!isScheduledToday) continue;
    
    const activityStart = minutesOf(activity.startTime);
    const activityEnd = minutesOf(activity.endTime);
    
    if (nowM >= activityStart && nowM < activityEnd) {
      return activity;
    }
  }
  
  return null;
}

async function cleanupDeletedGoals() {
  const currentGoalKeys = new Set();
  app.PEOPLE.forEach(person => {
    // Ensure goals array exists
    if (person.goals && Array.isArray(person.goals)) {
      person.goals.forEach(goal => {
        currentGoalKeys.add(person.id + '_' + goal.id);
      });
    }
  });
  
  Object.keys(app.goalState.streaks).forEach(key => {
    if (!currentGoalKeys.has(key)) {
      delete app.goalState.streaks[key];
    }
  });
  
  Object.keys(app.goalState.totals).forEach(key => {
    if (!currentGoalKeys.has(key)) {
      delete app.goalState.totals[key];
    }
  });
  
  Object.keys(app.goalState.lastCompletionDate).forEach(key => {
    if (!currentGoalKeys.has(key)) {
      delete app.goalState.lastCompletionDate[key];
    }
  });
  
  Object.keys(app.goalState.achievements).forEach(key => {
    if (!currentGoalKeys.has(key)) {
      delete app.goalState.achievements[key];
    }
  });
  
  await saveGoalState(app.goalState);
}

function createTaskRow(t) {
  const row = document.createElement('div');
  row.className = 'task-row';
  row.dataset.taskId = t.id || uid('t');
  
  row.innerHTML = `
    <input type="text" data-field="timeManual" placeholder="Time (e.g., 6:07 AM)" value="${t.time ? timeString12(t.time) : ''}"/>
    <input type="text" placeholder="Task label" value="${escapeHtml(t.label || '')}" data-field="label"/>
    <select data-field="frequency">
      <option value="daily" ${(t.frequency || 'daily') === 'daily' ? 'selected' : ''}>Daily</option>
      <option value="everyother" ${t.frequency === 'everyother' ? 'selected' : ''}>Every Other Day</option>
      <option value="weekdays" ${t.frequency === 'weekdays' ? 'selected' : ''}>Weekdays</option>
      <option value="weekends" ${t.frequency === 'weekends' ? 'selected' : ''}>Weekends</option>
    </select>
    <button class="btn small" data-action="removeTask">Remove</button>
  `;
  
  row.querySelector('[data-action="removeTask"]').onclick = async () => {
    const taskLabel = row.querySelector('input[data-field="label"]').value.trim() || 'this task';
    if (await confirmDialog('Remove "' + taskLabel + '"?')) {
      row.remove();
      saveEditor();
    }
  };
  return row;
}

async function saveEditor() {
  const getTime = (id) => {
    const v = document.getElementById(id).value;
    if (!v) return null;
    const parts = v.split(':');
    return {h: parseInt(parts[0], 10) || 0, m: parseInt(parts[1], 10) || 0};
  };
  
  const invalidTimes = [];
  app.dom.editorEl.querySelectorAll('.task-row').forEach(tr => {
    const manual = tr.querySelector('input[data-field="timeManual"]').value.trim();
    if (manual && !parseTimeFlexible(manual)) {
      const label = tr.querySelector('input[data-field="label"]').value.trim() || 'Unnamed task';
      invalidTimes.push(label);
    }
  });
  
  if (invalidTimes.length > 0) {
    alert('Please add AM or PM to the following tasks:\n\n' + invalidTimes.join('\n'));
    return;
  }
  
  app.CONFIG.appTitle = document.getElementById('appTitleInput').value.trim() || 'Family Checklists';
  app.CONFIG.resetHour = Math.max(0, Math.min(23, parseInt(document.getElementById('resetHourInput').value, 10) || 21));
  app.CONFIG.wakeParent = getTime('familyWakeInput') || {h: 6, m: 0};
  app.CONFIG.bedtimeKids = getTime('familyBedInput') || {h: 21, m: 0};
  app.CONFIG.morningEnd = getTime('morningEndInput') || {h: 12, m: 0};
  app.CONFIG.afternoonEnd = getTime('afternoonEndInput') || {h: 17, m: 0};
  
  const pinToggle = document.getElementById('pinToggle');
  app.CONFIG.pinEnabled = pinToggle.classList.contains('active');
  app.CONFIG.pinHint = document.getElementById('pinHintInput').value.trim();
  app.CONFIG.recoveryPhrase = document.getElementById('recoveryPhraseInput').value.trim();
  
  const newPin = document.getElementById('pinSetInput').value.trim();
  if (newPin) {
    app.CONFIG.pinSalt = app.CONFIG.pinSalt || uid('salt');
    app.CONFIG.pinHash = hashPin(newPin, app.CONFIG.pinSalt);
  }
  
  if (app.CONFIG.pinEnabled && !app.CONFIG.pinHash) {
    alert('Please set a PIN before enabling PIN protection.');
    app.CONFIG.pinEnabled = false;
  }
  
  const screensaverToggle = document.getElementById('screensaverToggle');
  app.CONFIG.screensaverEnabled = screensaverToggle.classList.contains('active');
  app.CONFIG.screensaverTimeout = Math.max(30, parseInt(document.getElementById('screensaverTimeoutInput').value, 10) || 300);
  app.CONFIG.screensaverGenre = document.getElementById('screensaverGenreInput').value;
  
  const selectedTheme = document.querySelector('.theme-option.selected');
  if (selectedTheme) {
    app.CONFIG.colorTheme = selectedTheme.dataset.theme;
  }
  
  const newPeople = [];
  app.dom.editorEl.querySelectorAll('.member-card').forEach(card => {
    if (!card.dataset.memberId) return;
    
    const name = card.querySelector('input[data-field="name"]').value.trim() || 'Member';
    const id = card.dataset.memberId;
    
    const useDefaultToggle = card.querySelector('[data-toggle="useDefaultTimes"]');
    const useDefaultTimes = useDefaultToggle.classList.contains('active');
    
    let wakeTime, bedTime;
    if (useDefaultTimes) {
      wakeTime = app.CONFIG.wakeParent;
      bedTime = app.CONFIG.bedtimeKids;
    } else {
      const wakeTimeVal = card.querySelector('input[data-field="wakeTime"]').value;
      wakeTime = wakeTimeVal ? {h: parseInt(wakeTimeVal.split(':')[0], 10), m: parseInt(wakeTimeVal.split(':')[1], 10)} : {h: 6, m: 0};
      
      const bedTimeVal = card.querySelector('input[data-field="bedTime"]').value;
      bedTime = bedTimeVal ? {h: parseInt(bedTimeVal.split(':')[0], 10), m: parseInt(bedTimeVal.split(':')[1], 10)} : {h: 21, m: 0};
    }
    
    const existingPerson = app.PEOPLE.find(px => px.id === id);
    const workSchoolStart = existingPerson?.workSchoolStart || {h: 8, m: 0};
    const workSchoolEnd = existingPerson?.workSchoolEnd || {h: 15, m: 0};
    const petName = existingPerson?.petName || 'Pet';
    const petEmoji = existingPerson?.petEmoji || '😄';
    
    const goals = [];
    card.querySelectorAll('[data-goal-id]').forEach(gr => {
      const goalName = gr.querySelector('input[data-field="goalName"]').value.trim();
      const goalType = gr.querySelector('select[data-field="goalType"]').value;
      const goalTarget = parseInt(gr.querySelector('input[data-field="goalTarget"]').value, 10) || 7;
      
      const selector = gr.querySelector('[data-field="taskSelector"]');
      let trackAll = true;
      let trackPeriod = null;
      let taskIds = [];
      
      if (selector && selector.querySelector('[data-track="all"]')) {
        const trackAllRadio = selector.querySelector('[data-track="all"]');
        const trackPeriodRadio = selector.querySelector('[data-track="period"]');
        const trackSpecificRadio = selector.querySelector('[data-track="specific"]');
        
        if (trackAllRadio.checked) {
          trackAll = true;
          trackPeriod = null;
          taskIds = [];
        } else if (trackPeriodRadio.checked) {
          trackAll = false;
          const periodSelector = selector.querySelector('[data-field="periodSelector"]');
          const selectedPeriod = periodSelector.querySelector('input[type="radio"]:checked');
          trackPeriod = selectedPeriod ? selectedPeriod.value : 'morning';
          taskIds = [];
        } else if (trackSpecificRadio.checked) {
          trackAll = false;
          trackPeriod = null;
          const specificTasks = selector.querySelector('[data-field="specificTasks"]');
          specificTasks.querySelectorAll('[data-task]:checked').forEach(cb => {
            taskIds.push(cb.dataset.task);
          });
        }
      } else {
        const existingPerson = app.PEOPLE.find(px => px.id === id);
        if (existingPerson && existingPerson.goals) {
          const existingGoal = existingPerson.goals.find(eg => eg.id === gr.dataset.goalId);
          if (existingGoal) {
            trackAll = existingGoal.trackAll;
            trackPeriod = existingGoal.trackPeriod || null;
            taskIds = existingGoal.taskIds || [];
          }
        }
      }
      
      if (goalName) {
        goals.push({
          id: gr.dataset.goalId || uid('goal'),
          name: goalName,
          type: goalType,
          target: goalTarget,
          trackAll,
          trackPeriod,
          taskIds
        });
      }
    });
    
    const activities = [];
    card.querySelectorAll('[data-activity-id]').forEach(ar => {
      const activityName = ar.querySelector('input[data-field="activityName"]').value.trim();
      const startTimeVal = ar.querySelector('input[data-field="startTime"]').value;
      const endTimeVal = ar.querySelector('input[data-field="endTime"]').value;
      
      const startTime = startTimeVal ? {h: parseInt(startTimeVal.split(':')[0], 10), m: parseInt(startTimeVal.split(':')[1], 10)} : {h: 16, m: 0};
      const endTime = endTimeVal ? {h: parseInt(endTimeVal.split(':')[0], 10), m: parseInt(endTimeVal.split(':')[1], 10)} : {h: 17, m: 0};
      
      const selector = ar.querySelector('[data-field="scheduleSelector"]');
      let schedule = 'everyday';
      let days = [];
      
      if (selector && selector.querySelector('input[type="radio"]:checked')) {
        const selectedRadio = selector.querySelector('input[type="radio"]:checked');
        schedule = selectedRadio.value;
        
        if (schedule === 'specific') {
          const specificDays = selector.querySelector('[data-field="specificDays"]');
          specificDays.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
            days.push(parseInt(cb.value, 10));
          });
        }
      } else {
        const existingPerson = app.PEOPLE.find(px => px.id === id);
        if (existingPerson && existingPerson.activities) {
          const existingActivity = existingPerson.activities.find(ea => ea.id === ar.dataset.activityId);
          if (existingActivity) {
            schedule = existingActivity.schedule || 'everyday';
            days = existingActivity.days || [];
          }
        }
      }
      
      if (activityName) {
        activities.push({
          id: ar.dataset.activityId || uid('activity'),
          name: activityName,
          schedule,
          days,
          startTime,
          endTime
        });
      }
    });
    
    const tasks = [];
    card.querySelectorAll('.task-row').forEach(tr => {
      const label = tr.querySelector('input[data-field="label"]').value.trim();
      const manual = tr.querySelector('input[data-field="timeManual"]').value;
      const frequency = tr.querySelector('select[data-field="frequency"]').value;
      const time = parseTimeFlexible(manual);
      const when = determineTaskPeriod(time);
      
      if (label) {
        tasks.push({id: tr.dataset.taskId || uid('t'), label, when, time, frequency: frequency || 'daily'});
      }
    });
    
    tasks.sort((a, b) => {
      if (a.time && b.time) return minutesOf(a.time) - minutesOf(b.time);
      if (a.time) return -1;
      if (b.time) return 1;
      return 0;
    });
    
    newPeople.push({id, name, useDefaultTimes, wakeTime, bedTime, workSchoolStart, workSchoolEnd, petName, petEmoji, activities, goals, tasks});
  });
  
  app.CONFIG.people = newPeople;
  app.PEOPLE = newPeople;
  await saveConfig(app.CONFIG);
  
  await cleanupDeletedGoals();
  
  app.dom.appTitleEl.textContent = app.CONFIG.appTitle;
  updateDayProgress();
  updateClockAndCountdown();
  
  const saveButtons = document.querySelectorAll('[data-action="saveMember"], #saveEdit');
  saveButtons.forEach(saveBtn => {
    const originalText = saveBtn.textContent;
    const originalClasses = saveBtn.className;
    saveBtn.textContent = 'Saved!';
    saveBtn.className = 'btn small saved';
    setTimeout(() => {
      saveBtn.textContent = originalText;
      saveBtn.className = originalClasses;
    }, 1000);
  });
  
  setTimeout(() => {
    renderEditor();
    applyColorTheme(app.CONFIG.colorTheme || 'blue');
  }, 1000);
}

function updateDayProgress() {
  const {done, total, pct} = overallCounts();
  const v = Math.round(pct);
  app.dom.dayProgBar.style.width = v + '%';
  app.dom.dayProg.setAttribute('aria-valuenow', String(v));
  app.dom.dayProg.setAttribute('aria-valuetext', done + '/' + total);
}

function updateClockAndCountdown() {
  const now = new Date();
  app.dom.clockEl.textContent = now.toLocaleTimeString([], {hour: 'numeric', minute: '2-digit', hour12: true});
  app.dom.subtitle.textContent = now.toLocaleDateString([], {weekday: 'long', month: 'long', day: 'numeric'});
  
  // Safety check
  if (!app.PEOPLE || !Array.isArray(app.PEOPLE)) {
    app.PEOPLE = [];
  }
  
  let earliestBedtime = null;
  app.PEOPLE.forEach(p => {
    if (p.bedTime) {
      const bedMins = minutesOf(p.bedTime);
      if (!earliestBedtime || bedMins < minutesOf(earliestBedtime)) {
        earliestBedtime = p.bedTime;
      }
    }
  });
  
  if (earliestBedtime) {
    const bedtime = new Date(now);
    bedtime.setHours(earliestBedtime.h, earliestBedtime.m, 0, 0);
    const diff = bedtime - now;
    
    if (diff > 0) {
      // Before bedtime - show countdown to bed
      const hrs = Math.floor(diff / 3600000);
      const mins = Math.floor((diff % 3600000) / 60000);
      
      let timeText = '';
      if (hrs > 0) {
        timeText = hrs + (hrs === 1 ? ' hour' : ' hours');
        if (mins > 0) {
          timeText += ' and ' + mins + (mins === 1 ? ' minute' : ' minutes');
        }
      } else if (mins > 0) {
        timeText = mins + (mins === 1 ? ' minute' : ' minutes');
      } else {
        timeText = 'less than a minute';
      }
      
      app.dom.bedtimeEl.textContent = timeText + ' until bedtime';
    } else {
      // Past bedtime - show countdown to morning
      const wakeTime = app.CONFIG.wakeParent || {h: 6, m: 0};
      const morning = new Date(now);
      morning.setHours(wakeTime.h, wakeTime.m, 0, 0);
      
      // If wake time already passed today, set to tomorrow
      if (morning <= now) {
        morning.setDate(morning.getDate() + 1);
      }
      
      const diffToMorning = morning - now;
      const hrsToMorning = Math.floor(diffToMorning / 3600000);
      const minsToMorning = Math.floor((diffToMorning % 3600000) / 60000);
      
      let morningText = '';
      if (hrsToMorning > 0) {
        morningText = hrsToMorning + (hrsToMorning === 1 ? ' hour' : ' hours');
        if (minsToMorning > 0) {
          morningText += ' and ' + minsToMorning + (minsToMorning === 1 ? ' minute' : ' minutes');
        }
      } else if (minsToMorning > 0) {
        morningText = minsToMorning + (minsToMorning === 1 ? ' minute' : ' minutes');
      } else {
        morningText = 'less than a minute';
      }
      
      app.dom.bedtimeEl.textContent = 'Sleeping. Morning in ' + morningText;
    }
  } else {
    app.dom.bedtimeEl.textContent = '';
  }
  
  const curMin = now.getHours() * 60 + now.getMinutes();
  if (curMin !== app.LAST_MIN) {
    app.LAST_MIN = curMin;
    if (!app.dom.summaryEl.classList.contains('hidden')) renderSummary();
    if (!app.dom.detailEl.classList.contains('hidden') && app.CURRENT_PERSON) {
      openDetail(app.CURRENT_PERSON);
    }
  }
}

function startScreensaver() {
  if (app.CONFIG.screensaverEnabled === false) return;
  
  let allContent;
  const genre = app.CONFIG.screensaverGenre || 'all';
  
  if (genre === 'all') {
    allContent = [
      ...SCREENSAVER_CONTENT.verses,
      ...SCREENSAVER_CONTENT.facts,
      ...SCREENSAVER_CONTENT.words
    ];
  } else {
    allContent = SCREENSAVER_CONTENT[genre] || SCREENSAVER_CONTENT.verses;
  }
  
  let currentIndex = Math.floor(Math.random() * allContent.length);
  
  const screensaver = document.createElement('div');
  screensaver.className = 'screensaver';
  screensaver.innerHTML = `
    <div class="screensaver-content" id="screensaverText">${escapeHtml(allContent[currentIndex])}</div>
    <div class="screensaver-hint">Tap anywhere to exit</div>
  `;
  
  document.body.appendChild(screensaver);
  
  // Rotate content every 15 seconds
  const rotateInterval = setInterval(() => {
    currentIndex = (currentIndex + 1) % allContent.length;
    const textEl = document.getElementById('screensaverText');
    if (textEl) {
      textEl.style.animation = 'none';
      setTimeout(() => {
        textEl.textContent = allContent[currentIndex];
        textEl.style.animation = 'floatAround 20s infinite ease-in-out';
      }, 50);
    }
  }, 15000);
  
  // Click to exit
  screensaver.onclick = () => {
    clearInterval(rotateInterval);
    screensaver.remove();
    if (window.resetInactivityTimer) {
      window.resetInactivityTimer();
    }
  };
}

const app = {
  CONFIG: null,
  state: null,
  goalState: null,
  PEOPLE: null,
  CURRENT_PERSON: null,
  LAST_MIN: -1,
  AUTH_UNTIL: 0,
  IGNORE_NEXT_STATE_UPDATE: false, // Flag to prevent Firebase sync conflicts
  dom: {
    summaryEl: document.getElementById('summary'),
    detailEl: document.getElementById('detail'),
    dashboardEl: document.getElementById('dashboard'),
    editorEl: document.getElementById('editor'),
    appTitleEl: document.getElementById('appTitle'),
    subtitle: document.getElementById('subtitle'),
    todayBtn: document.getElementById('todayBtn'),
    statsBtn: document.getElementById('statsBtn'),
    screensaverBtn: document.getElementById('screensaverBtn'),
    editBtn: document.getElementById('editBtn'),
    clockEl: document.getElementById('clock'),
    bedtimeEl: document.getElementById('bedtime'),
    dayProg: document.getElementById('dayProgress'),
    dayProgBar: document.getElementById('dayProgressBar')
  }
};

// Initialize app with Firebase data
(async function initApp() {
  try {
    app.CONFIG = await loadConfig();
    app.state = await loadState();
    app.goalState = await loadGoalState();
    app.PEOPLE = app.CONFIG.people || [];
    
    applyColorTheme(app.CONFIG.colorTheme || 'blue');
    
    // Set up real-time listeners for sync
    onValue(ref(database, 'state'), (snapshot) => {
      // Don't block listener updates - we want to see all changes
      if (snapshot.exists()) {
        const newState = snapshot.val();
        console.log('Received state from Firebase:', JSON.stringify(newState, null, 2)); // Debug log
        
        // Ensure all required properties exist (Firebase removes empty objects)
        if (!newState.checked) newState.checked = {};
        if (!newState.skipped) newState.skipped = {};
        if (!newState.overdueCompleted) newState.overdueCompleted = {};
        
        app.state = newState;
        
        // Always re-render the current view when state changes (unless actively saving)
        if (!syncInProgress) {
          if (!app.dom.summaryEl.classList.contains('hidden')) {
            renderSummary();
          } else if (!app.dom.detailEl.classList.contains('hidden') && app.CURRENT_PERSON) {
            openDetail(app.CURRENT_PERSON);
          }
        }
      }
    });
    
    onValue(ref(database, 'config'), (snapshot) => {
      if (snapshot.exists() && !syncInProgress) {
        const data = snapshot.val();
        // Ensure people array exists
        if (!data.people) data.people = [];
        app.CONFIG = data;
        app.PEOPLE = app.CONFIG.people || [];
        app.dom.appTitleEl.textContent = app.CONFIG.appTitle;
        applyColorTheme(app.CONFIG.colorTheme || 'blue');
      }
    });
    
    onValue(ref(database, 'goals'), (snapshot) => {
      if (snapshot.exists() && !syncInProgress) {
        app.goalState = snapshot.val();
        if (!app.dom.detailEl.classList.contains('hidden') && app.CURRENT_PERSON) {
          openDetail(app.CURRENT_PERSON);
        }
      }
    });
    
    app.dom.todayBtn.addEventListener('click', renderSummary);
    app.dom.statsBtn.addEventListener('click', renderDashboard);
    
    console.log('Screensaver button element:', app.dom.screensaverBtn);
    if (app.dom.screensaverBtn) {
      app.dom.screensaverBtn.addEventListener('click', startScreensaver);
      console.log('Screensaver button listener attached');
    } else {
      console.error('Screensaver button not found in DOM!');
    }
    
    app.dom.editBtn.addEventListener('click', async () => {
      if (!app.CONFIG.pinEnabled) {
        renderEditor();
      } else if (Date.now() < app.AUTH_UNTIL) {
        renderEditor();
      } else {
        const unlocked = await pinDialog();
        if (unlocked) {
          app.AUTH_UNTIL = Date.now() + (5 * 60 * 1000);
          renderEditor();
        }
      }
    });
    
    await ensureDailyReset();
    
    // Save daily snapshot at midnight
    const now = new Date();
    const midnight = new Date(now);
    midnight.setHours(24, 0, 0, 0);
    const msUntilMidnight = midnight - now;
    
    setTimeout(() => {
      saveHistoricalSnapshot();
      // Set up daily interval
      setInterval(saveHistoricalSnapshot, 24 * 60 * 60 * 1000);
    }, msUntilMidnight);
    
    app.dom.appTitleEl.textContent = app.CONFIG.appTitle;
    app.dom.subtitle.textContent = new Date().toLocaleDateString([], {weekday: 'long', month: 'long', day: 'numeric'});
    
    renderSummary();
    updateClockAndCountdown();
    updateDayProgress();
    setInterval(updateClockAndCountdown, 1000);
    
    // Set up inactivity timer after app is initialized
    let inactivityTimer = null;
    
    window.resetInactivityTimer = function() {
      if (inactivityTimer) clearTimeout(inactivityTimer);
      
      // Only set timer if we're on a detail page
      if (!app.dom.detailEl.classList.contains('hidden')) {
        inactivityTimer = setTimeout(() => {
          renderSummary();
        }, 30000); // 30 seconds for detail view to return to home
      }
    };
    
    // Add event listeners to reset timer on activity
    ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {
      document.addEventListener(event, window.resetInactivityTimer, true);
    });
  } catch (error) {
    console.error('Error initializing app:', error);
    alert('Error loading app. Please refresh the page. Error: ' + error.message);
  }
})();

})();
</script>
</body>
</html>
